<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[实现Qt程序的新版本检查]]></title>
      <url>/programming/2017/12/17/updateCheck/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>利用GitHub提供的API,实现程序的新版本检查功能。</strong></p>

<hr />

<h2 id="github的开发者api">GitHub的开发者API</h2>
<p>对于GitHub上的仓库，我们可以发布Release，每个Release除了源代码以外还可以附加编译后的二进制文件。发布Release之后便可以通过API获取一些有用的信息。不过需要注意的是，如下图所示，发布的Release是不能勾选“This is a pre-release”选项的。
<img src="http://localhost:4000/assets//blog_images/release.png" width="450px" height="200px" />
例如对于我的easyAuto仓库，那么API是<a href="https://api.github.com/repos/scienceasdf/accoutAssist/releases/latest">https://api.github.com/repos/scienceasdf/accoutAssist/releases/latest</a>。在浏览器中打开，可以看出这里提供json格式的许多信息。当然，如果是pre-release版本的话，就会得到下面的结果：</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{
  "message": "Not Found",
  "documentation_url": "https://developer.github.com/v3/repos/releases/#get-the-latest-release"
}
</code></pre></div></div>
<h2 id="qt的https请求与处理">Qt的HTTPS请求与处理</h2>
<p>首先需要在.pro文件中加上这两句，分别是加上网络模块和版本号的宏定义：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QT</span>      <span class="o">+=</span> <span class="p">...</span> <span class="n">network</span>
<span class="n">DEFINES</span> <span class="o">+=</span> <span class="s">"VERSION=2.2"</span>
</code></pre></div></div>
<p>接下来就是具体实现的代码：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include &lt;QtNetwork&gt;
</span><span class="c1">// ...
</span><span class="kt">void</span> <span class="n">accountAssit</span><span class="o">::</span><span class="n">on_checkUpdate_clicked</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">QNetworkAccessManager</span> <span class="n">networkManager</span><span class="p">;</span>


    <span class="n">QUrl</span> <span class="n">url</span><span class="p">(</span><span class="s">"https://api.github.com/repos/scienceasdf/accoutAssist/releases/latest"</span><span class="p">);</span>
    <span class="n">QNetworkRequest</span> <span class="n">request</span><span class="p">;</span>
    <span class="n">request</span><span class="p">.</span><span class="n">setUrl</span><span class="p">(</span><span class="n">url</span><span class="p">);</span>

    <span class="n">m_currentReply</span> <span class="o">=</span> <span class="n">networkManager</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">request</span><span class="p">);</span>  <span class="c1">// GET
</span>    <span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">networkManager</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">finished</span><span class="p">(</span><span class="n">QNetworkReply</span><span class="o">*</span><span class="p">)),</span> <span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">onResultUpdate</span><span class="p">(</span><span class="n">QNetworkReply</span><span class="o">*</span><span class="p">)));</span>
    <span class="n">QEventLoop</span> <span class="n">eventLoop</span><span class="p">;</span>
    <span class="n">QObject</span><span class="o">::</span><span class="n">connect</span><span class="p">(</span><span class="o">&amp;</span><span class="n">networkManager</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QNetworkAccessManager</span><span class="o">::</span><span class="n">finished</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">eventLoop</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">QEventLoop</span><span class="o">::</span><span class="n">quit</span><span class="p">);</span>
    <span class="n">eventLoop</span><span class="p">.</span><span class="n">exec</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">accountAssit</span><span class="o">::</span><span class="n">onResultUpdate</span><span class="p">(</span><span class="n">QNetworkReply</span> <span class="o">*</span> <span class="n">reply</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_currentReply</span><span class="o">-&gt;</span><span class="n">error</span><span class="p">()</span> <span class="o">!=</span> <span class="n">QNetworkReply</span><span class="o">::</span><span class="n">NoError</span><span class="p">){</span>
        <span class="c1">//qDebug()&lt;&lt;"ERROR!";
</span>        <span class="k">return</span><span class="p">;</span>  <span class="c1">// ...only in a blog post
</span>    <span class="p">}</span>

    <span class="n">QString</span> <span class="n">data</span> <span class="o">=</span> <span class="p">(</span><span class="n">QString</span><span class="p">)</span> <span class="n">reply</span><span class="o">-&gt;</span><span class="n">readAll</span><span class="p">();</span>
    <span class="n">qDebug</span><span class="p">()</span><span class="o">&lt;&lt;</span><span class="n">data</span><span class="p">;</span>
    <span class="n">QJsonDocument</span> <span class="n">d</span> <span class="o">=</span> <span class="n">QJsonDocument</span><span class="o">::</span><span class="n">fromJson</span><span class="p">(</span><span class="n">data</span><span class="p">.</span><span class="n">toUtf8</span><span class="p">());</span>
    <span class="n">QJsonObject</span> <span class="n">sett2</span> <span class="o">=</span> <span class="n">d</span><span class="p">.</span><span class="n">object</span><span class="p">();</span>
    <span class="n">QJsonValue</span> <span class="n">value</span> <span class="o">=</span> <span class="n">sett2</span><span class="p">.</span><span class="n">value</span><span class="p">(</span><span class="n">QString</span><span class="p">(</span><span class="s">"tag_name"</span><span class="p">));</span>
    <span class="n">qDebug</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">value</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span><span class="n">value</span><span class="p">.</span><span class="n">toDouble</span><span class="p">()</span> <span class="o">&gt;</span> <span class="n">VERSION</span><span class="p">){</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">StandardButton</span> <span class="n">button</span><span class="p">;</span>
        <span class="n">button</span> <span class="o">=</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">question</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">tr</span><span class="p">(</span><span class="s">"有新的版本"</span><span class="p">),</span>
                <span class="n">QString</span><span class="p">(</span><span class="n">tr</span><span class="p">(</span><span class="s">"是否下载新的版本？"</span><span class="p">)),</span>
                <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span> <span class="o">|</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">No</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">button</span> <span class="o">==</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span><span class="p">){</span>

        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">QMessageBox</span><span class="o">::</span><span class="n">information</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="s">"更新检查"</span><span class="p">,</span><span class="s">"此版本已经是最新发布版本"</span><span class="p">,</span> <span class="n">QMessageBox</span><span class="o">::</span><span class="n">Yes</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>在代码中，accountAssist是一个窗体，里面有一个类型为QNetworkReply*的重要成员：m_currentReply，用来保存网络是否正常的状态。当在获取HTTPS内容时，使用QEventLoop不阻塞GUI线程。当全文获取之后，转到槽函数onResultUpdate，对收到的所有内容进行处理。Qt自带了QJson的处理，非常的方便。如果发现最新版的release版本号大于宏定义的版本号，那么就提示有新的版本。不过这个也太简单粗暴了，如果版本号是从2.1更新到了2.10，这种方法就不奏效。解决方法也很简单，定义大版本号和小版本号，分别比较。比如“2.10”，QString自带了split函数，其实之前做easyAuto还可以用这个方法</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">QStringList</span> <span class="n">list</span> <span class="o">=</span> <span class="n">QString</span><span class="p">(</span><span class="s">"2.10"</span><span class="p">).</span><span class="n">split</span><span class="p">(</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
<span class="n">foreach</span><span class="p">(</span><span class="n">QString</span> <span class="n">str</span><span class="p">,</span> <span class="n">list</span><span class="p">){</span>
	<span class="c1">//...
</span><span class="p">}</span>
</code></pre></div></div>
<p>最后值得注意的是，在安卓程序里，必须要SSL连接，所以需要在网上下载libcrypto.so和libssl.so，并在.pro文件里加上</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>android {
  ANDROID_EXTRA_LIBS += $$PWD/libcrypto.so
  ANDROID_EXTRA_LIBS += $$PWD/libssl.so
}
</code></pre></div></div>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 网络 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[实现Qt程序的滑动手势]]></title>
      <url>/programming/2017/12/16/swipeGesture/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>Copy了一份实现单指滑动手势的源码。</strong></p>

<hr />
<p>Qt的SwipeGesture居然是要三个手指同时操作（这里是说用widget而不是用quick控件，实际上quick控件才是Qt为移动开发打造的）。把源码拿出来看了半天，看是能够看懂，可以就是改了就无法编译了。在GitHub上用搜索功能，终于找到了<a href="https://github.com/digifant/multidisplay-app/blob/b0921e1b0f0c728c58427029374bef072d0c4382/src/mobile/SwipeGestureRecognizer.h">直接可用的方案</a>（神奇的GitHub）：<br />
头文件,这里面的宏定义MINIMUM_DISTANCE = 50是可以根据需要修改的</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// customGesture.h
</span><span class="cp">#ifndef CUSTOMGESTURE_H
#define CUSTOMGESTURE_H
#include &lt;QGesture&gt;
#include &lt;QGestureRecognizer&gt;
#include &lt;QSwipeGesture&gt;
</span>
<span class="cm">/**

 * @brief The SwipeGestureRecognizer class

 * needed because the defalt implementation of swipe is a little bit odd: it only triggers on 3 finger swipes! (5.3)

 *

 * http://developer.android.com/design/patterns/gestures.html

 * http://qt-project.org/doc/qt-5/gestures-overview.html

 */</span>

<span class="k">class</span> <span class="nc">SwipeGestureRecognizer</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QGestureRecognizer</span>

<span class="p">{</span>

<span class="k">public</span><span class="o">:</span>

    <span class="n">SwipeGestureRecognizer</span><span class="p">();</span>





<span class="k">private</span><span class="o">:</span>

    <span class="cp">#ifdef FOR_DESKTOP
</span>   <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MINIMUM_DISTANCE</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="cp">#endif
#ifdef FOR_MOBILE
</span>   <span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">MINIMUM_DISTANCE</span> <span class="o">=</span> <span class="mi">50</span><span class="p">;</span>
<span class="cp">#endif
</span>

   <span class="k">typedef</span> <span class="n">QGestureRecognizer</span> <span class="n">parent</span><span class="p">;</span>



   <span class="kt">bool</span> <span class="n">IsValidMove</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">);</span>



   <span class="n">qreal</span> <span class="n">ComputeAngle</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">);</span>



   <span class="k">virtual</span> <span class="n">QGesture</span><span class="o">*</span> <span class="n">create</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="n">pTarget</span><span class="p">);</span>



   <span class="k">virtual</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">Result</span> <span class="n">recognize</span><span class="p">(</span><span class="n">QGesture</span><span class="o">*</span> <span class="n">pGesture</span><span class="p">,</span> <span class="n">QObject</span> <span class="o">*</span><span class="n">pWatched</span><span class="p">,</span> <span class="n">QEvent</span> <span class="o">*</span><span class="n">pEvent</span><span class="p">);</span>



   <span class="kt">void</span> <span class="n">reset</span> <span class="p">(</span><span class="n">QGesture</span> <span class="o">*</span><span class="n">pGesture</span><span class="p">);</span>

<span class="p">};</span>





<span class="k">class</span> <span class="nc">SwipeGestureUtil</span> <span class="p">{</span>

<span class="k">public</span><span class="o">:</span>

    <span class="k">static</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">SwipeDirection</span> <span class="n">GetHorizontalDirection</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">pSwipeGesture</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">SwipeDirection</span> <span class="n">GetVerticalDirection</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">pSwipeGesture</span><span class="p">);</span>


<span class="p">};</span>

<span class="cp">#endif // CUSTOMGESTURE_H
</span></code></pre></div></div>
<hr />
<p>源文件</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// customGesture.cpp
</span><span class="cp">#include &lt;QMouseEvent&gt;
</span>
<span class="cp">#include &lt;QDebug&gt;
</span>


<span class="cp">#include &lt;cmath&gt;
</span>
<span class="cp">#include "customgesture.h"
</span>


<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">SwipeGestureRecognizer</span><span class="p">()</span>

<span class="p">{</span>

<span class="p">}</span>



<span class="kt">bool</span>

<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">IsValidMove</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">)</span>

<span class="p">{</span>

   <span class="c1">// The moved distance is to small to count as not just a glitch.
</span>
   <span class="k">if</span> <span class="p">((</span><span class="n">qAbs</span><span class="p">(</span><span class="n">dx</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MINIMUM_DISTANCE</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">qAbs</span><span class="p">(</span><span class="n">dy</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">MINIMUM_DISTANCE</span><span class="p">))</span> <span class="p">{</span>

      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

<span class="p">}</span>





<span class="c1">// virtual
</span>
<span class="n">QGesture</span><span class="o">*</span>

<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">QObject</span><span class="o">*</span> <span class="n">pTarget</span><span class="p">)</span>

<span class="p">{</span>

   <span class="c1">//qDebug("SwipeGestureRecognizer::create() called");
</span>
   <span class="n">QGesture</span> <span class="o">*</span><span class="n">pGesture</span> <span class="o">=</span> <span class="k">new</span> <span class="n">QSwipeGesture</span><span class="p">(</span><span class="n">pTarget</span><span class="p">);</span>

   <span class="k">return</span> <span class="n">pGesture</span><span class="p">;</span>

<span class="p">}</span>





<span class="c1">// virtual
</span>
<span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">Result</span>

<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">recognize</span><span class="p">(</span><span class="n">QGesture</span><span class="o">*</span> <span class="n">pGesture</span><span class="p">,</span> <span class="n">QObject</span> <span class="o">*</span><span class="n">pWatched</span><span class="p">,</span> <span class="n">QEvent</span> <span class="o">*</span><span class="n">pEvent</span><span class="p">)</span>

<span class="p">{</span>

   <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">Result</span> <span class="n">result</span> <span class="o">=</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">Ignore</span><span class="p">;</span>

   <span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">pSwipe</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QSwipeGesture</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pGesture</span><span class="p">);</span>



   <span class="k">switch</span><span class="p">(</span><span class="n">pEvent</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">())</span> <span class="p">{</span>

      <span class="k">case</span> <span class="n">QEvent</span><span class="p">:</span><span class="o">:</span><span class="n">MouseButtonPress</span><span class="o">:</span> <span class="p">{</span>

         <span class="n">QMouseEvent</span><span class="o">*</span> <span class="n">pMouseEvent</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QMouseEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pEvent</span><span class="p">);</span>

<span class="cp">#if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
</span>
         <span class="n">pSwipe</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">"startPoint"</span><span class="p">,</span> <span class="n">pMouseEvent</span><span class="o">-&gt;</span><span class="n">posF</span><span class="p">());</span>

<span class="cp">#else
</span>
         <span class="n">pSwipe</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">"startPoint"</span><span class="p">,</span> <span class="n">pMouseEvent</span><span class="o">-&gt;</span><span class="n">localPos</span><span class="p">());</span>

<span class="cp">#endif
</span>
         <span class="n">result</span> <span class="o">=</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">MayBeGesture</span><span class="p">;</span>

         <span class="c1">//qDebug() &lt;&lt; "Swipe gesture started (start point=" &lt;&lt;  pSwipe-&gt;property("startPoint").toPointF() &lt;&lt;  ")";
</span>
      <span class="p">}</span>

      <span class="k">break</span><span class="p">;</span>

      <span class="k">case</span> <span class="n">QEvent</span><span class="p">:</span><span class="o">:</span><span class="n">MouseButtonRelease</span><span class="o">:</span> <span class="p">{</span>

         <span class="n">QMouseEvent</span><span class="o">*</span> <span class="n">pMouseEvent</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QMouseEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pEvent</span><span class="p">);</span>

         <span class="k">const</span> <span class="n">QVariant</span><span class="o">&amp;</span> <span class="n">propValue</span> <span class="o">=</span> <span class="n">pSwipe</span><span class="o">-&gt;</span><span class="n">property</span><span class="p">(</span><span class="s">"startPoint"</span><span class="p">);</span>

         <span class="n">QPointF</span> <span class="n">startPoint</span> <span class="o">=</span> <span class="n">propValue</span><span class="p">.</span><span class="n">toPointF</span><span class="p">();</span>

<span class="cp">#if QT_VERSION &lt; QT_VERSION_CHECK(5, 0, 0)
</span>
         <span class="n">QPointF</span> <span class="n">endPoint</span> <span class="o">=</span> <span class="n">pMouseEvent</span><span class="o">-&gt;</span><span class="n">posF</span><span class="p">();</span>

<span class="cp">#else
</span>
         <span class="n">QPointF</span> <span class="n">endPoint</span> <span class="o">=</span> <span class="n">pMouseEvent</span><span class="o">-&gt;</span><span class="n">localPos</span><span class="p">();</span>

<span class="cp">#endif
</span>


         <span class="c1">// process distance and direction
</span>
         <span class="kt">int</span> <span class="n">dx</span> <span class="o">=</span> <span class="n">endPoint</span><span class="p">.</span><span class="n">x</span><span class="p">()</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">.</span><span class="n">x</span><span class="p">();</span>

         <span class="kt">int</span> <span class="n">dy</span> <span class="o">=</span> <span class="n">endPoint</span><span class="p">.</span><span class="n">y</span><span class="p">()</span> <span class="o">-</span> <span class="n">startPoint</span><span class="p">.</span><span class="n">y</span><span class="p">();</span>



         <span class="c1">//bugfix: startPoint.isNull because we sometimes get false events with startpoint 0 -&gt; wrong swipe detected!
</span>
         <span class="k">if</span> <span class="p">(</span> <span class="p">(</span><span class="o">!</span><span class="n">IsValidMove</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">))</span> <span class="o">||</span> <span class="p">(</span> <span class="n">startPoint</span><span class="p">.</span><span class="n">isNull</span><span class="p">()</span> <span class="p">)</span> <span class="p">)</span> <span class="p">{</span>

            <span class="c1">// Just a click, so no gesture.
</span>
            <span class="n">result</span> <span class="o">=</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">CancelGesture</span><span class="p">;</span>

            <span class="c1">//qDebug("Swipe gesture canceled");
</span>
         <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>

            <span class="c1">// Compute the angle.
</span>
             <span class="c1">//qDebug() &lt;&lt; " startPoint= " &lt;&lt; startPoint &lt;&lt; " endPoint=" &lt;&lt; endPoint &lt;&lt; " dx=" &lt;&lt; dx &lt;&lt; " dy=" &lt;&lt; dy;
</span>
            <span class="n">qreal</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">ComputeAngle</span><span class="p">(</span><span class="n">dx</span><span class="p">,</span> <span class="n">dy</span><span class="p">);</span>

            <span class="n">pSwipe</span><span class="o">-&gt;</span><span class="n">setSwipeAngle</span><span class="p">(</span><span class="n">angle</span><span class="p">);</span>

            <span class="n">result</span> <span class="o">=</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">FinishGesture</span><span class="p">;</span>

            <span class="c1">//qDebug("Swipe gesture finished");
</span>
         <span class="p">}</span>

      <span class="p">}</span>

      <span class="k">break</span><span class="p">;</span>

      <span class="k">default</span><span class="o">:</span>

        <span class="k">break</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>



<span class="kt">void</span>

<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="n">QGesture</span> <span class="o">*</span><span class="n">pGesture</span><span class="p">)</span>

<span class="p">{</span>

   <span class="n">pGesture</span><span class="o">-&gt;</span><span class="n">setProperty</span><span class="p">(</span><span class="s">"startPoint"</span><span class="p">,</span> <span class="n">QVariant</span><span class="p">(</span><span class="n">QVariant</span><span class="o">::</span><span class="n">Invalid</span><span class="p">));</span>

   <span class="n">parent</span><span class="o">::</span><span class="n">reset</span><span class="p">(</span><span class="n">pGesture</span><span class="p">);</span>

<span class="p">}</span>



<span class="n">qreal</span>

<span class="n">SwipeGestureRecognizer</span><span class="o">::</span><span class="n">ComputeAngle</span><span class="p">(</span><span class="kt">int</span> <span class="n">dx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">dy</span><span class="p">)</span>

<span class="p">{</span>

   <span class="kt">double</span> <span class="n">PI</span> <span class="o">=</span> <span class="mf">3.14159265</span><span class="p">;</span>



   <span class="c1">// Need to convert from screen coordinates direction
</span>
   <span class="c1">// into classical coordinates direction.
</span>
   <span class="n">dy</span> <span class="o">=</span> <span class="o">-</span><span class="n">dy</span><span class="p">;</span>



   <span class="kt">double</span> <span class="n">result</span> <span class="o">=</span> <span class="n">atan2</span><span class="p">((</span><span class="kt">double</span><span class="p">)</span><span class="n">dy</span><span class="p">,</span> <span class="p">(</span><span class="kt">double</span><span class="p">)</span><span class="n">dx</span><span class="p">)</span> <span class="p">;</span>

   <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="n">result</span> <span class="o">*</span> <span class="mi">180</span><span class="p">)</span> <span class="o">/</span> <span class="n">PI</span><span class="p">;</span>



   <span class="c1">// Always return positive angle.
</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>

      <span class="n">result</span> <span class="o">+=</span> <span class="mi">360</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">return</span> <span class="n">result</span><span class="p">;</span>

<span class="p">}</span>







<span class="cm">/*

==========================================================================

*/</span>



<span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">SwipeDirection</span>

<span class="n">SwipeGestureUtil</span><span class="o">::</span><span class="n">GetHorizontalDirection</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">pSwipeGesture</span><span class="p">)</span>

<span class="p">{</span>

   <span class="n">qreal</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">pSwipeGesture</span><span class="o">-&gt;</span><span class="n">swipeAngle</span><span class="p">();</span>

   <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">angle</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">45</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Right</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">if</span> <span class="p">(</span><span class="mi">135</span> <span class="o">&lt;=</span> <span class="n">angle</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">225</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Left</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">if</span> <span class="p">(</span><span class="mi">315</span> <span class="o">&lt;=</span> <span class="n">angle</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;=</span> <span class="mi">360</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Right</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">NoDirection</span><span class="p">;</span>

<span class="p">}</span>



<span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">SwipeDirection</span>

<span class="n">SwipeGestureUtil</span><span class="o">::</span><span class="n">GetVerticalDirection</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">pSwipeGesture</span><span class="p">)</span>

<span class="p">{</span>

   <span class="n">qreal</span> <span class="n">angle</span> <span class="o">=</span> <span class="n">pSwipeGesture</span><span class="o">-&gt;</span><span class="n">swipeAngle</span><span class="p">();</span>



   <span class="k">if</span> <span class="p">(</span><span class="mi">45</span> <span class="o">&lt;</span> <span class="n">angle</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">135</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Up</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">if</span> <span class="p">(</span><span class="mi">225</span> <span class="o">&lt;</span> <span class="n">angle</span> <span class="o">&amp;&amp;</span> <span class="n">angle</span> <span class="o">&lt;</span> <span class="mi">315</span><span class="p">)</span> <span class="p">{</span>

      <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Down</span><span class="p">;</span>

   <span class="p">}</span>



   <span class="k">return</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">NoDirection</span><span class="p">;</span>

<span class="p">}</span>
</code></pre></div></div>
<p>使用代码就很简单了，比如某个窗体的头文件</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">rangeReport</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>
    <span class="c1">// ...
</span><span class="nl">private:</span>
    <span class="c1">// ...
</span>    <span class="n">SwipeGestureRecognizer</span> <span class="o">*</span><span class="n">fftRecognizer</span><span class="p">;</span>
    <span class="n">Qt</span><span class="o">::</span><span class="n">GestureType</span> <span class="n">fftType</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">swipeTriggered</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">gesture</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="kt">bool</span> <span class="n">gestureEvent</span><span class="p">(</span><span class="n">QGestureEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">);</span>

    <span class="kt">int</span> <span class="n">currentGraph</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">registerGesture</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>而源文件就是要注册这个手势识别器，并实现手势之后的响应</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">rangeReport</span><span class="o">::</span><span class="n">rangeReport</span><span class="p">(</span><span class="n">rangeType</span> <span class="n">type</span><span class="p">)</span><span class="o">:</span>
    <span class="n">ui</span><span class="p">(</span><span class="k">new</span> <span class="n">Ui</span><span class="o">::</span><span class="n">rangeReport</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">ui</span><span class="o">-&gt;</span><span class="n">setupUi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="n">registerGesture</span><span class="p">();</span>
    <span class="c1">// ...
</span><span class="p">}</span>
<span class="c1">// ...
</span><span class="kt">bool</span> <span class="n">rangeReport</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">QEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">event</span><span class="o">-&gt;</span><span class="n">type</span><span class="p">()</span> <span class="o">==</span> <span class="n">QEvent</span><span class="o">::</span><span class="n">Gesture</span><span class="p">){</span>
        <span class="c1">//qDebug()&lt;&lt;"grab!";
</span>        <span class="k">return</span> <span class="n">gestureEvent</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QGestureEvent</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">event</span><span class="p">));</span>
    <span class="p">}</span>
        <span class="k">return</span> <span class="n">QWidget</span><span class="o">::</span><span class="n">event</span><span class="p">(</span><span class="n">event</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">rangeReport</span><span class="o">::</span><span class="n">swipeTriggered</span><span class="p">(</span><span class="n">QSwipeGesture</span> <span class="o">*</span><span class="n">gesture</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">gesture</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">()</span> <span class="o">==</span> <span class="n">Qt</span><span class="o">::</span><span class="n">GestureFinished</span><span class="p">)</span> <span class="p">{</span>
           <span class="k">if</span> <span class="p">(</span><span class="n">gesture</span><span class="o">-&gt;</span><span class="n">horizontalDirection</span><span class="p">()</span> <span class="o">==</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Left</span>
               <span class="o">||</span> <span class="n">gesture</span><span class="o">-&gt;</span><span class="n">verticalDirection</span><span class="p">()</span> <span class="o">==</span> <span class="n">QSwipeGesture</span><span class="o">::</span><span class="n">Up</span><span class="p">)</span> <span class="p">{</span>
               <span class="k">if</span><span class="p">(</span><span class="n">currentGraph</span> <span class="o">!=</span> <span class="n">chart</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">){</span>
                   <span class="n">currentGraph</span> <span class="o">++</span><span class="p">;</span>
                   <span class="n">ui</span><span class="o">-&gt;</span><span class="n">graph1</span><span class="o">-&gt;</span><span class="n">setChart</span><span class="p">(</span><span class="n">chart</span><span class="p">[</span><span class="n">currentGraph</span><span class="p">]);</span>
               <span class="p">}</span>
           <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
               <span class="k">if</span><span class="p">(</span><span class="n">currentGraph</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">){</span>
                   <span class="n">currentGraph</span> <span class="o">--</span><span class="p">;</span>
                   <span class="n">ui</span><span class="o">-&gt;</span><span class="n">graph1</span><span class="o">-&gt;</span><span class="n">setChart</span><span class="p">(</span><span class="n">chart</span><span class="p">[</span><span class="n">currentGraph</span><span class="p">]);</span>
               <span class="p">}</span>                          <span class="c1">//?ui-&gt;tabWidget-&gt;count():ui-&gt;tabWidget-&gt;currentIndex() + 1 );
</span>           <span class="p">}</span>
           <span class="n">update</span><span class="p">();</span>
       <span class="p">}</span>
<span class="p">}</span>


<span class="kt">bool</span> <span class="n">rangeReport</span><span class="o">::</span><span class="n">gestureEvent</span><span class="p">(</span><span class="n">QGestureEvent</span> <span class="o">*</span><span class="n">event</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//qDebug() &lt;&lt; "gestureEvent():" &lt;&lt; event;
</span>    <span class="k">if</span> <span class="p">(</span><span class="n">QGesture</span> <span class="o">*</span><span class="n">swipe</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">gesture</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">SwipeGesture</span><span class="p">))</span>
        <span class="n">swipeTriggered</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">QSwipeGesture</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">swipe</span><span class="p">));</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">QGesture</span> <span class="o">*</span><span class="n">pan</span> <span class="o">=</span> <span class="n">event</span><span class="o">-&gt;</span><span class="n">gesture</span><span class="p">(</span><span class="n">Qt</span><span class="o">::</span><span class="n">PanGesture</span><span class="p">))</span>
        <span class="c1">//panTriggered(static_cast&lt;QPanGesture *&gt;(pan));
</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">rangeReport</span><span class="o">::</span><span class="n">registerGesture</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">fftRecognizer</span> <span class="o">=</span> <span class="k">new</span> <span class="n">SwipeGestureRecognizer</span><span class="p">();</span>
    <span class="n">fftType</span> <span class="o">=</span> <span class="n">QGestureRecognizer</span><span class="o">::</span><span class="n">registerRecognizer</span><span class="p">(</span><span class="n">fftRecognizer</span><span class="p">);</span>
    <span class="n">grabGesture</span><span class="p">(</span><span class="n">fftType</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>
<p>最后还是要吐槽一下sqlite:我觉得这个数据库的性能特别好，查询速度很快，占用资源也少。不过为什么不支持全外连接语句:angry:让我用连接和并集写全外连接不是白白增加工作量吗？:facepunch:</p>

]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[easyAuto的单元测试]]></title>
      <url>/programming/2017/11/16/easyautoTest/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>出于各种考虑，在easyAuto里面我第一次写了单元测试。</strong></p>

<hr />

<h2 id="单元测试">单元测试</h2>
<p>以前写代码从来不注重单元测试，不过这次在easyAuto项目里我觉得有必要进行单元测试了。因为包括计算各种穿越频率、处理输入输出这些，常常会修改算法，即使是小改，也不敢保证一切正常。程序刚写出来的时候是我自己输入并看结果是否符合预期。不过这样实在很费精力，因此自己写了单元测试，也是我第一次写单元测试:trollface:。</p>

<blockquote>
  <p>代码是为了什么，当然是为了重复运行。如何保持unit test代码的稳定？主要靠好的API设计。API切实正确切割了需求，那么在重构的时候API就基本不用变化，unit test也不用重写。以后你重构的时候，只要你的unit test覆盖的够好，基本跑一遍就知道有没有改成**。可以节省大量的时间。</p>

  <p>作者：vczh<br />
链接：https://www.zhihu.com/question/28729261/answer/94964928<br />
来源：知乎<br />
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
</blockquote>

<p>虽然单元测试有许多现成的框架，例如<a href="https://github.com/boostorg/test">Boost::test</a>,<a href="http://doc.qt.io/qt-5/qtest-overview.html">Qt单元测试框架</a>,<a href="https://github.com/catchorg/Catch2">catch2</a>这些，但是从减少折腾成本考虑，我就直接用assert来做单元测试，毕竟在C++之父在他的书里也是用这样的方法进行单元测试的:grin:。</p>

<h2 id="对传递函数相关代码进行单元测试">对传递函数相关代码进行单元测试</h2>
<p>首先，由于这个代码以及未来的大量代码都需要对数值进行检验，所以定义如下函数</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="kt">bool</span> <span class="n">fuzzyEqual</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">T</span> <span class="n">b</span><span class="p">,</span> <span class="n">T</span> <span class="n">relativeErr</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">((</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">+</span> <span class="n">relativeErr</span><span class="p">))</span> <span class="o">*</span>
       <span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">b</span> <span class="o">*</span> <span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="o">-</span> <span class="n">relativeErr</span><span class="p">))</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">){</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>传递函数相关的需要测试以下的内容：</p>
<ul>
  <li>多项式相乘是否正确；</li>
  <li>大量的从自动控制原理的书上找来的传递函数，来测试是否能够正确输出穿越频率、各种裕度；</li>
  <li>若传递函数表示的线性系统有两个180°穿越频率，给定猜测初值计算能否收敛，不给定初值是否收敛到任意一个值？</li>
</ul>

<h2 id="对处理用户输入输出相关代码进行测试">对处理用户输入输出相关代码进行测试</h2>
<p>需要测试的内容包括：</p>
<ul>
  <li>将用户输入的内容进行分割，并转换为正确的多项式</li>
  <li>将多项式以富文本的形式输出，包括按照平时书写习惯正确处理系数是0,1以及正负号的问题</li>
</ul>

<h2 id="集成测试">集成测试</h2>
<p>最后写两个大的用例，进行整个完整功能的测试（根轨迹的输出我实在不知道如何测试）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "comprehensiveTest.h"
#include "util.h"
#include "../strop.h"
#include "../trans.h"
</span>
<span class="cp">#include &lt;cassert&gt;
#include &lt;fstream&gt;
</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">genericErr</span> <span class="o">=</span> <span class="mf">1e-3</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">compTestCase1</span><span class="p">();</span>
<span class="kt">void</span> <span class="n">compTestCase2</span><span class="p">();</span>

<span class="kt">void</span> <span class="nf">comprehensiveTest</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">compTestCase1</span><span class="p">();</span>
    <span class="n">compTestCase2</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">compTestCase1</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">numStr</span> <span class="o">=</span> <span class="s">"5*12.5 1"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">denStr</span> <span class="o">=</span> <span class="s">"1 0*1 1*0.5 1*111.111 1"</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">num</span> <span class="o">=</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="n">numStr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">den</span> <span class="o">=</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="n">denStr</span><span class="p">);</span>

    <span class="n">trans</span> <span class="n">tsfunc</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">den</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">phaseMargin</span><span class="p">,</span> <span class="n">freq1</span><span class="p">;</span>
    <span class="n">tsfunc</span><span class="p">.</span><span class="n">phaseMargin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">phaseMargin</span><span class="p">,</span><span class="o">&amp;</span><span class="n">freq1</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">gainMargin</span><span class="p">,</span> <span class="n">freq2</span><span class="p">;</span>
    <span class="n">tsfunc</span><span class="p">.</span><span class="n">gainMargin</span><span class="p">(</span><span class="o">&amp;</span><span class="n">gainMargin</span><span class="p">,</span><span class="o">&amp;</span><span class="n">freq2</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="n">fuzzyEqual</span><span class="p">(</span><span class="n">phaseMargin</span><span class="p">,</span><span class="mf">41.6</span><span class="p">,</span><span class="n">genericErr</span><span class="p">));</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">fuzzyEqual</span><span class="p">(</span><span class="n">freq1</span><span class="p">,</span><span class="mf">0.4955</span><span class="p">,</span><span class="n">genericErr</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">compTestCase2</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">numStr</span> <span class="o">=</span> <span class="s">"95.238 286.6759"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">denStr</span> <span class="o">=</span> <span class="s">"1 15.3339 110.5719 286.6759"</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">num</span> <span class="o">=</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="n">numStr</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">den</span> <span class="o">=</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="n">denStr</span><span class="p">);</span>

    <span class="n">trans</span> <span class="n">tsfunc</span><span class="p">(</span><span class="n">num</span><span class="p">,</span><span class="n">den</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">tsfunc</span><span class="p">.</span><span class="n">unitStepResponse</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span><span class="mi">100</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span> <span class="n">fout</span><span class="p">(</span><span class="s">"D:/out.txt"</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">fout</span><span class="p">.</span><span class="n">is_open</span><span class="p">()</span> <span class="o">==</span> <span class="nb">false</span><span class="p">){</span>

    <span class="p">}</span><span class="k">else</span><span class="p">{</span>
        <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="n">i</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">){</span>
            <span class="n">fout</span><span class="o">&lt;&lt;</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;&lt;</span><span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>
<p>第二个用例是计算系统响应的，这里还是把结果输出到了一个文件中，然后我来检查:disappointed:。应该在这里也实现自动化的测试。<br />
在测试项目的main.cpp里只需写如下代码：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include "transTest.h"
#include "stroptest.h"
#include "comprehensiveTest.h"
</span>
<span class="cp">#include &lt;cassert&gt;
#include &lt;iostream&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">transTest</span><span class="p">();</span>

    <span class="n">strOpTest</span><span class="p">();</span>

    <span class="n">comprehensiveTest</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>每次修改过源文件中的某些函数，只要接口不变，就可以立即重新编译测试项目并运行，看看在修改代码之后代码是否还能正常工作。不过绘制根轨迹这个我是实在不知道如何构造测试用例啊:dizzy_face:！</p>

]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 自动控制 </tag>
        
          <tag> 单元测试 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[在手机上绘制根轨迹]]></title>
      <url>/programming/2017/11/15/easyauto/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>写了一个能够绘制线性系统根轨迹、响应曲线、计算幅值裕度、相位裕度等的手机APP。下载地址在文末。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="算法">算法</h2>
<h3 id="各种裕度的计算">各种裕度的计算</h3>
<p>很简单，就是用弦截法计算各种穿越频率，然后计算裕度。具体的代码以及API设计可以见GitHub，不过弦截法
需要给出猜测初值，在手机里这个程序也就只能在几个初值里面试，如果这个初值迭代不收敛就换另一个初值
。目前的算法能够通过所有我写的测试用例，不过不知道是否有不对的情况。</p>
<h3 id="与绘制各种根轨迹相关的算法">与绘制各种根轨迹相关的算法</h3>
<h4 id="多项式求根算法">多项式求根算法</h4>
<p>非常美妙的事情是，NDK虽然是个大坑，不过Eigen库还是能够使用的。<br />
多项式的求根可以转化为它的companion matrix的特征值问题来求解：<br />
$p(t)=c_{0}+c_{1}t+\cdots +c_{n-1}t^{n-1}+t^{n}$的companion matrix是<br />
<script type="math/tex">% <![CDATA[
\begin{equation} \tag{a}
C(p)=\begin{bmatrix}
0 & 0 & \dots & 0 & -c_{0}\\
1 & 0 & \dots & 0 & -c_{1}\\
0 & 1 & \dots & 0 & -c_{2}\\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \dots & 1 & -c_{n-1}
\end{bmatrix}
\end{equation} %]]></script>
这样就可以将多项式求根问题转化为矩阵的特征值问题，然后利用Eigen库求解。</p>
<h4 id="排序算法">排序算法</h4>
<p>由于Eigen求出特征值是无序的，而绘图时是按照方程的根的离散点连线绘制，因此可能会造成各条轨迹交织的情况。为了避免这种情况，需要对根进行排序，即这组点到上组点的距离分别最近进行排序。
这个没有想到更好的点子，实现的算法复杂度为$O(n^2)$，但是在手机上没有卡过，代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matsz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
 <span class="err"> </span> <span class="err"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">i</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="err"> </span> 
 <span class="err"> </span> <span class="err"> </span><span class="c1">// static variables don't need to be captured
</span>    <span class="p">{</span><span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]);}));</span>
 <span class="err">  </span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="计算响应的算法">计算响应的算法</h3>
<p>这个一开始想用矩阵的幂来进行计算，但是发现许多时候线性系统的$\mathbf{A}$矩阵都是奇异的，没办法，
还是只能用RK45算法，好在现在手机处理器性能很强，没有任何卡的迹象。</p>

<h2 id="处理用户输入">处理用户输入</h2>
<p>为了让用户能够有更好的交互体验，设计的输入格式比较宽送。处理用户输入用了Boost::tokenizer库，这是一个Header-only的库，不需要编译（当然我也自己编译了Boost库，除了Math库编译不了，别的都可以编译，具体能不能用还没有认真试过）。NDK真的是一个大坑，GOOGLE官方对GCC值支持到GCC4.9，然而Qt for Android是GCC编译的，而GCC4.9对C++14支持不全不说，有的C++11的东西都没法用，比如std::stod,std::to_string，所以先自己实现一个。。。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef FOR_MOBILE
</span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">os</span> <span class="p">;</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="p">;</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//template &lt;typename T&gt;
</span>    <span class="kt">double</span> <span class="n">stod</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="p">(</span> <span class="n">str</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>
<p>用户的输入可以是这样的格式：“1 2 3 * -3 1 * 2,-1*2,-1 0”，通常用户的输入都是以各个零极点为根的多项式之积，*是各个相乘多项式之间的分隔符, 而空白和英文逗号可以作为多项式中各个系数
 之间的分隔符，表示的多项式就是(s<sup>2</sup>+2s+3)(-3s+1)(2s-1)(2s<sup>2</sup>-s).于是采用Boost::tokenizer将字符串进行两层分割：第一层是乘法运算符*，第二层则是空格和英文逗号。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include &lt;boost/tokenizer.hpp&gt;
</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">poly</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sep</span><span class="p">(</span><span class="s">" ,"</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tok</span><span class="p">(</span><span class="n">myString</span><span class="p">,</span><span class="n">sep</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">beg</span><span class="o">=</span><span class="n">tok</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">beg</span><span class="o">!=</span><span class="n">tok</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">beg</span><span class="p">){</span>
        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stod</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">rawText</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sep</span><span class="p">(</span><span class="s">"*"</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tok</span><span class="p">(</span><span class="n">rawText</span><span class="p">,</span><span class="n">sep</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">beg</span><span class="o">=</span><span class="n">tok</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">beg</span><span class="o">!=</span><span class="n">tok</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">beg</span><span class="p">){</span>
        <span class="k">auto</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">convolution</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">vec</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这段代码的作用是将用户输入分割，并且返回成一个多项式。在这里我自己实现了一个多项式的std::vector<double>用来表示多项式的系数，并实现乘法运算convolution，并且在线性系统的类中也有两个多项式成员：传递函数的分子和分母。</double></p>

<p>实际上使用Boost::tokenizer是一种比较简单可行的方式，也可以用Boost::splitter或者用正则表达式匹配甚至直接自己写一个简单parser都可以实现功能。</p>

<h2 id="多项式的富文本输出">多项式的富文本输出</h2>
<p>为了让用户直观地知道输入的格式代表的多项式，应该在QLabel中将多项式以富文本的形式输出，而且应该<strong><em>同时输出多项式相乘和多项式展开的形式</em></strong>，这里多项式输出时为了追求完美，符合平时的习惯，应该特别注意系数为0,1以及正负号的问题。具体代码太长，见<a href="https://github.com/scienceasdf/easyAuto">GitHub仓库</a>。</p>
<h2 id="截图">截图</h2>
<p><img src="http://localhost:4000/assets//blog_images/shot1.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/shot2.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/shot3.png" width="350px" height="200px" /></p>
<h2 id="其他">其他</h2>
<ul>
  <li>这个APP的创意出自我的室友，他觉得每次做完自动控制原理的题之后又要打开电脑开MATLAB去检验非常麻烦，这个APP就能够解决这样的问题</li>
  <li>APP中绘制根轨迹的增益K是用户输入的，而且绘图时是从0到K线性地取1000个点进行计算绘制，这样的效果并不一定是最好的。在MATLAB中绘制根轨迹的增益取值算法值得借鉴</li>
  <li>本来用的是QCustomPlot来绘制曲线的，结果这个东西在手机上的渲染效果很差，于是改成了
QtCharts，发现这个模块优点很多，而且在手机上显示的效果很好</li>
  <li>虽然GOOGLE的NDK非常坑，不过有一个替代方案据说还是不错的：Crystax NDK，不过自从2017年就没有发布新版本了，社区也不太活跃（GitHub上的代码倒还在改）</li>
</ul>

<hr />

<p><a href="https://github.com/scienceasdf/easyAuto/releases/download/v1.1/easyAuto.apk">APK下载地址（GitHub镜像）</a>
<a href="https://pan.baidu.com/s/1c4ewHnM">APK下载地址（百度网盘镜像）</a></p>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 自动控制 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
          <tag> 数值算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[太阳高度角与方位角的计算]]></title>
      <url>/programming/2017/10/22/soalrAngle/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨太阳高度角与方位角的计算，并写了个手机程序用于计算此时此刻此地（也可以是任意时刻，任意地点）的太阳高度角与方位角.</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="基本算法">基本算法</h2>
<p>就是一大堆玄学（或者叫天文学）的概念了。</p>
<h3 id="当地正午时间">当地正午时间</h3>
<p>给定经度$\Phi$（都假设是东经，主要研究中国国土范围内的问题），那么当地的正午时间在北京时间下的时间可以表示成：（这个感觉用代码比公式更加直观）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">timeType</span> <span class="nf">getNoonTime</span><span class="p">(</span><span class="kt">double</span> <span class="n">longitude</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// assume in the eastern semi-sphere
</span>    <span class="c1">// expressed in UTC+8 time
</span>    <span class="c1">// longtitude expressed in degrees
</span>    <span class="kt">int</span> <span class="n">dt</span><span class="o">=</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mf">120.0</span><span class="o">-</span><span class="n">longitude</span><span class="p">));</span>
    <span class="n">timeType</span> <span class="n">t1</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">t1</span><span class="o">+=</span><span class="n">dt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="太阳时角">太阳时角</h3>
<p>太阳时角是指日面中心的时角，即从观测点天球子午圈沿天赤道量至太阳所在时圈的角距离。计算公式为
\begin{equation}
h=15\times (ST-12)
\end{equation}
$ST$为真太阳时。然而平常我们通常都使用北京时间，因此太阳时角的计算公式如下：（还是感觉代码比公式更直观）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">getHourAngle</span><span class="p">(</span><span class="kt">double</span> <span class="n">longitude</span><span class="p">,</span> <span class="k">const</span> <span class="n">timeType</span><span class="o">&amp;</span> <span class="n">t1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// The results return the angle expressed in degrees
</span>    <span class="c1">// also UTC+8
</span>    <span class="n">timeType</span> <span class="n">t2</span><span class="o">=</span><span class="n">getNoonTime</span><span class="p">(</span><span class="n">longitude</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">dt</span><span class="o">=</span><span class="n">t1</span><span class="o">-</span><span class="n">t2</span><span class="p">;</span>
    <span class="k">return</span> <span class="mf">.25</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="太阳赤纬">太阳赤纬</h3>
<p>太阳赤纬，是地球赤道平面与太阳和地球中心的连线之间的夹角。赤纬角以年为周期，在+23 °26′与-23 °26′的范围内移动，成为季节的标志。最简单的方法是将
赤纬的变化考虑为线性变化。在一篇参考文献上，给出了更为近似的计算方式：按照三角函数变化规律计算。我在这里也按照这种方式计算。而百度百科还给出了一
个更加精确的公式:
\begin{equation} \label{preci}
\delta=0.006918-0.399912 \cos (b)+0.070257 \sin (b)-0.006758 \cos (2b)+ 0.000907\sin (2b)-0.002697\cos (3b)+0.00148\sin (3b)
\end{equation}
其中</p>
<ul>
  <li>$\delta$的单位为度(deg)；</li>
  <li>$\pi$=3.1415926为圆周率；</li>
  <li>$b=2\pi (N-1)/365$，单位为弧度；</li>
  <li>$N$为日数，自每年1月1日开始计算。  <br />
有空去把程序改成这个公式再去跑跑。</li>
</ul>

<h3 id="太阳高度角的计算">太阳高度角的计算</h3>
<p>\begin{equation}
\sin \theta_\mathrm{s} = \cos h \cos \delta \cos \Phi + \sin \delta \sin \Phi \,,
\end{equation}
此处</p>
<ul>
  <li>$\theta_\mathrm{s}$是太阳高度角，</li>
  <li>$h$是以地方恒星时系统下的时角，</li>
  <li>$\delta$是目前的太阳赤纬，</li>
  <li>$\Phi$是当地的纬度。</li>
</ul>

<h3 id="太阳方位角的计算">太阳方位角的计算</h3>
<p>在维基百科上查到的是如下的近似公式
\begin{equation}
\cos \phi _\mathrm {s}=\frac {\sin \delta -\sin \theta _\mathrm {s}\sin \Phi }{cos\theta _\mathrm {s}\cos \Phi }
\end{equation}</p>

<h2 id="程序相关">程序相关</h2>
<p>前面的代码也可以看出，这个问题需要自己实现时间类timeType和日期类dateType，包括一些基本的运算操作，不过也可以用Boost库的或者用Qt的。编程的时候需要特别小心角度与弧度的换算。在安卓程序中需要实现对设备的经纬度定位，还是要感谢Qt，让一切变得十分方便。<br />
类Widget作为主窗体，定义如下：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Widget</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Ui</span><span class="o">::</span><span class="n">Widget</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

    <span class="n">QGeoPositionInfoSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span> <span class="n">info</span><span class="p">);</span>
<span class="k">private</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">on_updateButton_clicked</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>具体定位的代码如下：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
    <span class="n">ui</span><span class="p">(</span><span class="k">new</span> <span class="n">Ui</span><span class="o">::</span><span class="n">Widget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">QGeoPositionInfoSource</span><span class="o">*</span> <span class="n">source2</span> <span class="o">=</span> <span class="n">QGeoPositionInfoSource</span><span class="o">::</span><span class="n">createDefaultSource</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">source2</span><span class="p">){</span>
        <span class="n">source2</span><span class="o">-&gt;</span><span class="n">setUpdateInterval</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">source2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">positionUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span><span class="p">)),</span><span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span><span class="p">)));</span>
        <span class="n">source2</span><span class="o">-&gt;</span><span class="n">startUpdates</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// ...
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">latitude</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">coordinate</span><span class="p">().</span><span class="n">latitude</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">longitude</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">coordinate</span><span class="p">().</span><span class="n">longitude</span><span class="p">();</span>

    <span class="n">QTime</span> <span class="n">time1</span> <span class="o">=</span> <span class="n">QTime</span><span class="o">::</span><span class="n">currentTime</span><span class="p">();</span>
    <span class="n">timeType</span> <span class="n">td1</span><span class="p">(</span><span class="n">time1</span><span class="p">.</span><span class="n">hour</span><span class="p">(),</span><span class="n">time1</span><span class="p">.</span><span class="n">minute</span><span class="p">());</span>

    <span class="n">QDate</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">QDate</span><span class="o">::</span><span class="n">currentDate</span><span class="p">();</span>

    <span class="kt">double</span> <span class="n">timeAngle</span><span class="o">=</span><span class="n">getHourAngle</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span><span class="n">td1</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">elevAngle</span><span class="o">=</span><span class="n">getSolarElevationAngle</span><span class="p">(</span><span class="n">getSolarDeclination</span><span class="p">(</span><span class="n">d1</span><span class="p">),</span><span class="n">latitude</span><span class="p">,</span><span class="n">timeAngle</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">azimuth</span><span class="o">=</span><span class="n">getSolarAzimuthAngle</span><span class="p">(</span><span class="n">getSolarDeclination</span><span class="p">(</span><span class="n">d1</span><span class="p">),</span><span class="n">latitude</span><span class="p">,</span><span class="n">timeAngle</span><span class="p">,</span><span class="n">elevAngle</span><span class="p">);</span>
	<span class="c1">// ...
</span><span class="p">}</span>
</code></pre></div></div>

<h2 id="应用">应用</h2>
<ul>
  <li>和Stellarium里面的太阳高度角、方位角进行了对比，虽然在这里的计算中有些是近似公式，但是误差也不会超过1°</li>
  <li>这个程序，这种方法让我在外地，只要有晴天，就能找到东西南北</li>
  <li>这个程序还可以应用于一些太阳能实验上，如太阳能飞机的动力试车，大概选在哪些月份，哪些时刻，或者说如何调整电池片的方向以使电池片接收到最多的太阳光强能够心里有数</li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 天文 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈螺旋桨航模（无人机）的动力系统选配（二）]]></title>
      <url>/programming/2017/08/17/propulsion2/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨了螺旋桨无人机动力系统的相关理论，并开发手机与电脑版程序解决相关问题。下载地址在文末。</strong></p>

<hr />
<p>上一篇文章我们讲了螺旋桨无人机动力系统相关的理论，这篇文章说说程序的设计。</p>

<h2 id="数据来源">数据来源</h2>
<p>所有的数据都来自于APC官网的数据。由于APC螺旋桨高效率的优点（正品APC桨的效率非常高，接近0.9），以及APC在其官网公布了所有型号的理论性能数据文件，故下载所有其官网上的五百个左右性能数据文件，其文件已经存储为固定的格式。先在官网上下载索引文件PER2_TITLEDAT.txt，再用wget批量将所有的螺旋桨性能数据文件下载下来。一共五百来个文件，中间下载是否有连接错误导致文件没有下载完整我也不知道:sweat:。APC的桨型号很齐全，基本覆盖了航模级别常用的尺寸，从几英寸到26英寸的都有，如果在这些型号以外的型号那就没办法了。。。数据全部都是dat格式的，用std::ifstream读文件非常耗时。对于开发的安卓版本，肯定不会用External folder里面包含所有的数据，只能用Qt资源文件+QDataStream来读写（不支持std::ifstream)，这样速度更快，不过缺点在于如果数据变动、扩展会不太方便。在写完所有程序之后，我还把所有数据迁移到了一个sqlite数据库文件中，并加上索引，访问速度大大提升，不过目前是不想重构sqlite的版本了。</p>

<h2 id="功能介绍">功能介绍</h2>
<p>程序分为PC版和移动（安卓）版，主要以介绍PC版为主。PC版共有两个程序：DemoProp，用于计算无刷电机动力系统的工作状况并给出一定的建议；PropChart，用于计算电动和油动动力系统的工作状况并绘制图表。</p>
<h3 id="筛选功能">筛选功能</h3>
<p>程序可以对给定的工作状况下的符合要求（如拉力、效率等条件）的螺旋桨进行筛选。DemoProp的筛选界面如下图所示，可以输入电机、电源、减速组等相关信息。
<img src="http://localhost:4000/assets//blog_images/fig2.png" width="350px" height="200px" />
PropChart的筛选界面如下图所示，这里运用的模型是给定转速或者给定输入功率，这样就既能够用于求解电动系统的工作状况，也适用于求解油动系统的工作状况。
<img src="http://localhost:4000/assets//blog_images/fig4.png" width="350px" height="200px" /></p>

<h3 id="分析功能">分析功能</h3>
<p>DemoProp能够对具体的电动系统选配提出指导意见，可以判断当前电机、电源、螺旋桨、减速组的组合究竟是轻载、超载还是正常载荷，如下图所示。
<img src="http://localhost:4000/assets//blog_images/fig3.png" width="350px" height="200px" /></p>

<h3 id="图表功能">图表功能</h3>
<p>PropChart能够绘制螺旋桨的拉力曲线、效率曲线等等，这里我用的是QCustomPlot进行绘制，如下图所示。
<img src="http://localhost:4000/assets//blog_images/fig5.png" width="350px" height="200px" /></p>

<h3 id="移动版">移动版</h3>
<p>一直苦于在室外进行动力试验的时候，不方便将测量的数据与仿真数据进行校对、不知道动力系统应该怎么调整。感谢伟大的Qt的跨平台特性，让我能够将程序移植到安卓系统上（实际上移植到iOS上也可以，不过就是我没有苹果电脑与手机），极大地方便了在外场的实验。针对手机的一些特点，在功能上进行了一些改进，例如取消筛选功能，并增加绘制能量分析饼图的功能。手机版的交互体验应该比电脑版的好太多了。截图如下：
<img src="http://localhost:4000/assets//blog_images/scr2.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/scr3.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/scr1.png" width="350px" height="200px" /></p>
<h2 id="数据验证">数据验证</h2>
<h3 id="静拉力实测数据验证">静拉力实测数据验证</h3>
<p>测试仿APC12X6E螺旋桨,飓风2820电机，$K_v=920$
，内阻28mOhm，静拉力1.7千克力，电流47-48安，转速8300RPM。仿真结果为静拉力2.3千克力，转速8830RPM。考虑到APC官网的数据本来比实际值偏高（参考文献的风洞实验数据有验证），误差与使用偏高值以及没有使用正品APC螺旋桨有关。</p>
<h3 id="应用于太阳能飞机动力系统的例子">应用于太阳能飞机动力系统的例子</h3>
<p>某翼展为5米的太阳能无人机，没有储能装置，太阳能提供动力系统的所有能量。机翼上的电池片大约提供110瓦电能。实验测试测得电池片能够提供的电压大约不超过13V，电流不超过8A。最早使用KV值1000的电机驱动20英寸的自制螺旋桨，静拉力输出很难超过1千克力。换用340KV电机带20英寸以上的木桨，静拉力能够超过10千克力。经计算表明，电机KV值在200附近时驱动20$\sim$22英寸螺旋桨能够有更高效率，换用200KV螺旋桨，以及APC22X10E的螺旋桨，静拉力为1.35千克力。</p>
<h2 id="存在的问题">存在的问题</h2>
<ul>
  <li>筛选功能卡在IO上比较耗时间。当然，MSVC编译的程序能够明显快于MINGW编译的程序。解决方法有很多，只是我不想去重构了</li>
  <li>电脑版的交互体验非常差</li>
  <li>电脑版没有对UI进行多分辨率的调整</li>
</ul>

<hr />
<p><a href="https://pan.baidu.com/s/1QaN9CxFEfJz0RHewitcCgg">安卓版程序下载地址</a><br />
<a href="https://pan.baidu.com/s/1W5DtxZFxC6SmjRxvO9F_tA">Windows版程序下载地址（32位）</a></p>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 无人机 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈螺旋桨航模（无人机）的动力系统选配（一）]]></title>
      <url>/programming/2017/08/17/propulsion1/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨了螺旋桨无人机动力系统的相关理论，并开发手机与电脑版程序解决相关问题。下载地址在文末。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="动力系统的数学模型">动力系统的数学模型</h2>
<h3 id="无刷电机的数学模型">无刷电机的数学模型</h3>
<p>有<br />
<script type="math/tex">\begin{equation} \label{eqs:1} \tag{a}
\left \{
\begin{array}{l}
U=r_a I+\frac{n}{K_v}\\
I=\frac{M_{em}}{K_m}
\end{array}
\right.
\end{equation}</script>
其中，$r_a$为电机内阻，$U$为电机两端电压，$I$为通过电机的电流，$K_v$为电机Kv值，$K_m$为电机转矩常数，$n$为电机转速(RPM)，$M_{em}$是电机的电磁转矩。<br />
电机的输出转矩为
\begin{equation}
M_{mot}=M_{em}-M_{R}=k_m(I-I_0)
\end{equation}
$K_v$的量纲为RPM/V，$K_m$的量纲是N$\cdot$m/A，在国际单位制下电机的$K_v$与$K_m$满足关系
\begin{equation}
K_m=\frac{60}{2\pi K_v }
\end{equation}
电机的输入功率为
\begin{equation}
P_{in}=UI
\end{equation}
输出功率为
\begin{equation}
P_{out}=\frac{2\pi nM_{mot}}{60}
\end{equation}
电机的效率为
\begin{equation}
%\eta=\frac{P_{out}}{P_{in}}=\frac{2\pi nM_{mot}}{60UI}
\eta =\frac{P_{out}}{P_{in}}=\frac{2\pi nM_{mot}}{60UI}
\end{equation}</p>

<h3 id="螺旋桨的数学模型">螺旋桨的数学模型</h3>
<p>对于螺旋桨，转矩$M$、拉力$T$、功率$P$、效率$\eta$都是空速$v$、螺旋桨转速$n$的函数
<script type="math/tex">\begin{equation} \label{basics} \tag{b}
\left\{
\begin{array}{l}
M=M(v,n)\\
T=T(v,n)=C_T(v,n)\cdot\rho n^2 D^4\\
P=P(v,n)=C_P(v,n)\cdot\rho n^3 D^5\\
\eta=\eta(v,n)
\end{array}
\right.
\end{equation}</script><br />
$C_T$是拉力系数、$C_P$是功率系数，且有$P=M\cdot\frac{2\pi n}{60}$，$\eta=\frac{Tv}{P}$。<br />
定义一个无量纲参数进动比(advance ratio)
\begin{equation} J=\frac{v}{nD}\end{equation}
$D$为螺旋桨直径。<br />
通常，$\eta$与$J$的变化关系如下图所示。在进行初步分析的手工计算中，可以认为$J$是一个相似性判定的参数，如果同一螺旋桨，工作在1状况$(v_1,n_1)$与2状况$(v_2,n_2)$，满足进动比相同，即$\frac{v_1}{n_1}=\frac{v_2}{n_2}$，则可以认为工作状况下的效率$\eta$、拉力系数$C_T$、功率系数$C_P$均相同。如果要估算某一工作状况$(v,n)$的工作参数，仅需先计算进动比$J=\frac{v}{nD}$，然后查找对应进动比的相关$\eta,C_T\text{和}C_P$，然后按照式(\ref{basics})计算拉力、转矩、效率与功率。
<img src="http://localhost:4000/assets//blog_images/fig1.png" width="350px" height="200px" />
实际上，由于低雷诺数的影响，对于进动比相同的两种工作状况，$\eta,C_T\text{和}C_P$并不一定对应相等。通常高雷诺数的工作状况下螺旋桨的工作效率更高。</p>
<h3 id="电源模型">电源模型</h3>
<p>通常，无人机上使用的电源为蓄电池。蓄电池电源的伏安特性关系为：
\begin{equation} \label{eqs:src1}
U=U_0-Ir_0 <br />
\end{equation}
其中$r_0$为蓄电池内阻。
 对于太阳能无人机，通常是太阳能电池直接为蓄电池充电，由蓄电池驱动直流电机，那么电机两端的电压电流关系满足式(\ref{eqs:src1}).而若太阳能无人机有特殊的要求(如某些太阳能飞机竞赛),那么设计的飞机会是太阳能电池片组直接为动力系统供电。太阳能电池片组的伏安特性关系为
\begin{equation}\label{solar_array} 
I=I_{sc}[1-A(e^{U/BU_{oc}})-1]
\end{equation}
其中，<script type="math/tex">A=(1-\frac{I_m}{I_{sc}})e^{-U_m/(BU_{oc})}</script><br />
<script type="math/tex">B=(\frac{U_m}{U_{oc}}-1)[\ln(1-\frac{I_m}{I_{sc}})]</script><br />
$I_{sc}$为电池组的短路电流;<br />
$U_{oc}$为电池组的开路电压;<br />
$U_m,I_m$为最大功率点处的太阳能电池的输出电压与电流.</p>

<h3 id="综合模型及其求解">综合模型及其求解</h3>
<p>已知飞机的飞行速度$v$，无刷电机的$K_v$值，内阻$r_a$与10V下空载电流$i_0$，以及螺旋桨对应的性能数据，则利用电机转矩等于螺旋桨转矩的关系，求解在电压与电流下的转速$n$，其它参数则可对应求解。电源的电压和电流可以符合某种伏安特性曲线,如式(\ref{eqs:src1})、(\ref{solar_array})，求解过程则为弦截法对转速迭代求解。电源也可能是具有限流或限压值，也可以给出电源电压与电流的上限，求解时取转速上限恰好同时满足不超过电源电压与电流的上限。</p>
<h3 id="非平凡模型">非平凡模型</h3>
<h4 id="引入减速组">引入减速组</h4>
<p>设减速组减速比为$K$，机械效率为$\eta_g$，则有<br />
<script type="math/tex">\begin{equation} \tag{c}
\left\{
\begin{array}{l}
n_{prop}=\frac{n_{mot}}{K}\\
T_{prop}=K\cdot T_{mot}\cdot\eta_g
\end{array}
\right.
\end{equation}</script>
考虑$\eta_g=1$的理想减速器，与电机形成的系统可以等效为一个$K_v$值折合为原电机$K_v$值$\frac{1}{K}$的新电机。通常高效率螺旋桨的特征都是低负载、大直径、大桨距（相对于直径）、低速运行，所以为了动力系统的效率最大化应该用大直径螺旋桨。由于带动大直径螺旋桨所需的转矩大，如果需要使电机工作在最大电流以下，可以使用减速组或使用低$K_v$值的电机。然而低$K_v$值得电机内阻会比高$K_v$值得电机内阻大，使用减速组会有机械能损失。而且大直径螺旋桨的重量大，且能驱动大直径螺旋桨的电机或减速器通常重量也较大。故具体应选用的方案，应考虑效率、重量、成本、加工装配难度等多方面考虑。</p>

<h4 id="单电机驱动两个螺旋桨">单电机驱动两个螺旋桨</h4>
<p>在这种情况下，有<br />
<script type="math/tex">\begin{equation} \label{eqs:12} \tag{d}
\left\{
\begin{array}{l}
n_{prop}=n_{mot}\\
M_{prop}=\frac{M_{mot}}{2}
\end{array}
\right.
\end{equation}</script>
求解上式则可以求出电机的转速。双电机驱动单螺旋桨及其它类似情况可以按照类似的方法列出公式求解。</p>
<h3 id="内燃机的特性">内燃机的特性</h3>
<p>无人机上使用的内燃机通常可分为两行程发动机和四行程发动机。两行程发动机与四行程发动机相比，优点是功率大，可动零件少，维护简便，价格便宜；缺点是油料燃烧不充分，燃料消耗大。两行程发动机还有两个显著特点：</p>
<ul>
  <li>使用这类发动机的无人机，爬升时经常可以听到转速明显下降的声音，俯冲时可以明显听到转速明显升高的声音，原因是这种发动机的扭矩小，对负载的变化较敏感。为了减小这种影响，两行程发动机一般使用大直径小桨距螺旋桨。</li>
  <li>两行程发动机转速普遍较高，也只有在高速下才能发挥出全部功率，所以厂家提供的功率数据也是要达到一定转速。二行程发动机最大的缺点是油门非线性。</li>
</ul>

<p>四行程发动机的优点是油门线性好，扭矩大，转速稳定，声音柔和，可以使用大桨距的螺旋桨，提高效率。四行程发动机工作室燃料燃烧充分。无人机爬升时，转速稳定、爬升有力、声音无变化。而四行程的缺点是价格昂贵，重量较大，维护不便。同样的工作容积，普通的四行程发动机输出功率理论上只有两行程发动机的一半，但是实际上不同于二行程发动机，四行程发动机的最大输出功率是在一般使用中可以达到要求的转速范围内的。<br />
由参考文献,对于高亚音速的飞机，内燃机的功率会随着速度的增加而增大；而对于大多数慢速飞机，内燃机的功率可以认为不变。大多数无人机的巡航速度下发动机的功率可以认为近似不变，那么对应其最大输出功率、最大输出转矩，通常需要一个合适的转速，否则发动机性能无法得到最大发挥。</p>

<hr />
<p><a href="https://pan.baidu.com/s/1QaN9CxFEfJz0RHewitcCgg">安卓版程序下载地址</a><br />
<a href="https://pan.baidu.com/s/1W5DtxZFxC6SmjRxvO9F_tA">Windows版程序下载地址（32位）</a><br />
由于博文过长会导致浏览器加载、渲染速度降低，故后续讨论请看下一篇文章。</p>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 无人机 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[轨道动力学中常用的计算机算法（二）]]></title>
      <url>/programming/2017/04/14/astrodynamics2/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>这里是一些轨道动力学中常见物理量的计算机算法的总结。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="偏近点角">偏近点角</h2>
<ul>
  <li>已知：$\nu,e$</li>
  <li>求：$EA$</li>
</ul>

<p>如果$e&gt;(1-10\times{-11})$，那么$EA=0$，否则
\begin{equation}\sin(EA)=\frac{\sqrt{1-e^2}\sin\nu}{1+e\cos\nu}\end{equation}
\begin{equation}\cos(EA)=\frac{e+\cos\nu}{1+e\cos\nu}\end{equation}
\begin{equation} \label{EA}
EA=atan2(\sin EA,\cos EA)\end{equation}</p>

<p>在资料里还查到了双曲线的Hyperbolic Anomaly(HA)，因为是双曲线轨道，先不写在这里了。</p>

<h2 id="平近点角">平近点角</h2>
<ul>
  <li>已知：$\nu,e$</li>
  <li>求：$MA$</li>
</ul>

<p>对于椭圆轨道($e\leq 10\times{-11}$)，首先按照式(\ref{EA})算出偏近点角，然后
\begin{equation} MA=EA-e\sin EA\end{equation}
这个公式是和平均角速度的公式混合食用的：
\begin{equation}
n=\sqrt{\frac{\mu}{\pm a^3}}\end{equation}
正负号是因为双曲线的半长轴是负的。</p>

<h2 id="偏近点角到真近点角">偏近点角到真近点角</h2>
<ul>
  <li>已知：$EA,e$</li>
  <li>求：$\nu$</li>
</ul>

<p>\begin{equation}\sin\nu=\frac{\sqrt{1-e^2}\sin EA}{1-e\cos EA} \end{equation}
\begin{equation}\cos\nu=\frac{\cos EA -e}{1-e\cos EA} \end{equation}
\begin{equation}\nu=atan2(\sin\nu,\cos\nu)\end{equation}</p>

<h2 id="平近点角到偏近点角">平近点角到偏近点角</h2>
<ul>
  <li>已知：$MA,e$</li>
  <li>求：$EA$</li>
</ul>

<p>就是一个牛顿迭代法，这里直接给出实现的代码</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">MA2EA</span><span class="p">(</span><span class="kt">double</span> <span class="n">MA</span><span class="p">,</span> <span class="kt">double</span> <span class="n">ecc</span><span class="p">)</span>
<span class="p">{</span>

    <span class="k">if</span><span class="p">(</span><span class="n">ecc</span><span class="o">&lt;</span><span class="mf">1.0</span><span class="p">){</span>
        <span class="c1">//elliptic orbit case
</span>        <span class="kt">double</span> <span class="n">E</span><span class="p">;</span>
        <span class="k">if</span><span class="p">((</span><span class="n">MA</span><span class="o">&lt;</span><span class="mf">.0</span> <span class="o">&amp;&amp;</span> <span class="n">MA</span><span class="o">&gt;-</span><span class="n">pi</span><span class="p">)</span><span class="o">||</span><span class="p">(</span><span class="n">MA</span><span class="o">&gt;</span><span class="n">pi</span><span class="p">))</span>
            <span class="n">E</span><span class="o">=</span><span class="n">MA</span><span class="o">-</span><span class="n">ecc</span><span class="p">;</span>
        <span class="k">else</span>
            <span class="n">E</span><span class="o">=</span><span class="n">MA</span><span class="o">+</span><span class="n">ecc</span><span class="p">;</span>

        <span class="kt">double</span> <span class="n">E_</span><span class="o">=</span><span class="n">MA</span><span class="p">;</span>
        <span class="k">while</span><span class="p">(</span><span class="n">fabs</span><span class="p">(</span><span class="n">E</span><span class="o">-</span><span class="n">E_</span><span class="p">)</span><span class="o">&gt;</span><span class="mf">1e-8</span><span class="p">){</span>
            <span class="n">E_</span><span class="o">=</span><span class="n">E</span><span class="p">;</span>
            <span class="n">E</span><span class="o">=</span><span class="n">E</span><span class="o">+</span><span class="p">(</span><span class="n">MA</span><span class="o">-</span><span class="n">E</span><span class="o">+</span><span class="n">ecc</span><span class="o">*</span><span class="n">sin</span><span class="p">(</span><span class="n">E</span><span class="p">))</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">-</span><span class="n">ecc</span><span class="o">*</span><span class="n">cos</span><span class="p">(</span><span class="n">E</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">E</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="轨道外推的算法">轨道外推的算法</h2>
<p>根据上面各个角之间的转换关系，就可以实现轨道外推。写一个类，封装轨道六根数：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">KeplerianState</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">SMA</span><span class="p">;</span>     <span class="c1">//semimajor axis, a
</span>    <span class="kt">double</span> <span class="n">ECC</span><span class="p">;</span>     <span class="c1">//eccentricity, e
</span>    <span class="kt">double</span> <span class="n">INC</span><span class="p">;</span>     <span class="c1">//inclination, i
</span>    <span class="kt">double</span> <span class="n">AOP</span><span class="p">;</span>     <span class="c1">//argument of periapsis, \omega
</span>    <span class="kt">double</span> <span class="n">RAAN</span><span class="p">;</span>    <span class="c1">//right ascension of the ascending node, \Omega
</span>    <span class="kt">double</span> <span class="n">TA</span><span class="p">;</span>      <span class="c1">//true anomaly, \phi
</span>
    <span class="n">KeplerianState</span><span class="p">(){}</span>
    <span class="n">KeplerianState</span><span class="p">(</span><span class="kt">double</span> <span class="n">a</span><span class="p">,</span> <span class="kt">double</span> <span class="n">e</span><span class="p">,</span> <span class="kt">double</span> <span class="n">i</span><span class="p">,</span> <span class="kt">double</span> <span class="n">omega</span><span class="p">,</span> <span class="kt">double</span> <span class="n">Omega</span><span class="p">,</span> <span class="kt">double</span> <span class="n">phi</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mu</span><span class="o">=</span><span class="mf">3.986004415e14</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">SMA</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">ECC</span><span class="p">(</span><span class="n">e</span><span class="p">),</span> <span class="n">INC</span><span class="p">(</span><span class="n">i</span><span class="p">),</span> <span class="n">AOP</span><span class="p">(</span><span class="n">omega</span><span class="p">),</span> <span class="n">RAAN</span><span class="p">(</span><span class="n">Omega</span><span class="p">),</span> <span class="n">TA</span><span class="p">(</span><span class="n">phi</span><span class="p">),</span> <span class="n">gravityConst</span><span class="p">(</span><span class="n">mu</span><span class="p">)</span> <span class="p">{}</span>
    <span class="o">~</span><span class="n">KeplerianState</span><span class="p">(){}</span>

    <span class="kt">void</span> <span class="n">toCartesian</span><span class="p">(</span><span class="n">vec3</span><span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">vec3</span><span class="o">*</span> <span class="n">vel</span><span class="p">);</span>
    <span class="kt">void</span> <span class="n">step</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">);</span>

    <span class="k">static</span> <span class="n">KeplerianState</span> <span class="n">fromR_V</span><span class="p">(</span><span class="k">const</span> <span class="n">vec3</span><span class="o">&amp;</span> <span class="n">r</span><span class="p">,</span> <span class="k">const</span> <span class="n">vec3</span><span class="o">&amp;</span> <span class="n">v</span><span class="p">,</span> <span class="kt">double</span> <span class="n">mu</span><span class="o">=</span><span class="mf">3.98600445e14</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>
    <span class="kt">double</span> <span class="n">gravityConst</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>
<p>轨道外推就是用平均角速度乘时间得到平近点角，然后再转化至真近点角：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="n">KeplerianState</span><span class="o">::</span><span class="n">step</span><span class="p">(</span><span class="kt">double</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">MA</span><span class="o">=</span><span class="n">TA2MA</span><span class="p">(</span><span class="n">TA</span><span class="p">,</span><span class="n">ECC</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">n</span><span class="o">=</span><span class="n">pow</span><span class="p">(</span><span class="n">gravityConst</span><span class="o">/</span><span class="n">SMA</span><span class="o">/</span><span class="n">SMA</span><span class="o">/</span><span class="n">SMA</span><span class="p">,</span><span class="mf">.5</span><span class="p">);</span>
    <span class="n">MA</span><span class="o">+=</span><span class="n">n</span><span class="o">*</span><span class="n">t</span><span class="p">;</span>    <span class="c1">// t seconds later
</span>    <span class="n">TA</span><span class="o">=</span><span class="n">MA2TA</span><span class="p">(</span><span class="n">MA</span><span class="p">,</span><span class="n">ECC</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<h2 id="近地点远地点速度">近地点、远地点速度</h2>
<ul>
  <li>已知：$a,e,\mu$</li>
  <li>求：$v_a,v_p$</li>
</ul>

<p>如果$e &gt; ( 1 - 10\times{−12} )$，那么$v_a=0$，否则
\begin{equation}v_a=\sqrt{\frac{\mu}{a}(\frac{1-e}{1+e})}
\end{equation}
\begin{equation}v_p=\sqrt{\frac{\mu}{a}(\frac{1+e}{1-e})}
\end{equation}</p>

<hr />
<p><strong>注意这些公式带入运算时都是要化成弧度的！！！</strong></p>

]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 天文 </tag>
        
          <tag> 数值算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[轨道动力学中常用的计算机算法]]></title>
      <url>/programming/2017/04/07/astrodynamics1/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>这里是一些轨道动力学中常见物理量的计算机算法的总结。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<p>最近专业课又是轨道动力学又是姿态动力学什么的，非常有意思。在航天器动力学里面有太多的算法可以讲，从时间转换、坐标系的转换到轨道外推这些，刚体动力学其实还可以借鉴游戏引擎的一些思路。自己最近借学习这些课程的机会，自己实现了3维向量、3阶方阵、四元数的轮子。关于刚体动力学，在航天中也就是姿态动力学的探讨不在本文。这篇文章总结一些轨道动力学常见物理量的算法。</p>

<h2 id="笛卡尔坐标系转换到轨道六根数">笛卡尔坐标系转换到轨道六根数</h2>
<p><img src="http://localhost:4000/assets//blog_images/Keplerian.png" width="600px" height="400px" /></p>
<ul>
  <li>已知：$\mathbf{r},\mathbf{v}$和引力常数$\mu$</li>
  <li>求：$a,e,i,\omega,\Omega,\nu$</li>
</ul>

<p>\begin{equation} \mathbf{h} = \mathbf{r}\times\mathbf{v}\end{equation}
\begin{equation} h = ||\mathbf{h}||\end{equation}
升交线方向的矢量是
\begin{equation} \mathbf{n}=[0,0,1]^T\times\mathbf{h}\end{equation}
\begin{equation} n = ||\mathbf{n}||\end{equation}
轨道的离心率和能量通过以下式子计算
\begin{equation} \mathbf{e} = \frac{(v^2-\frac{\mu}{r})\mathbf{r}-(\mathbf{r}\cdot\mathbf{v})\mathbf{v}}{\mu}\end{equation}
\begin{equation}e=||\mathbf{e}||\end{equation}
\begin{equation}\xi = \frac{v^2}{2}-\frac{\mu}{r}\end{equation}
对于抛物线轨道，半长轴是正无穷而能量是0.这里要做的工作是检查轨道是否是近抛物线轨道。如果$|1-e|&lt;10^{-7}$，就要另外讨论了。<br />
半长轴的计算公式为
\begin{equation}a=-\frac{\mu}{2\xi}\end{equation}
轨道倾角：
\begin{equation}i=\arccos(\frac{h_z}{h})\end{equation}
计算升交点赤经，近地点角距，真近点角需要分四种情况处理<br />
<strong><em>情况1：对于非圆，非赤道平面的轨道</em></strong><br />
如果$(e \geq 10^{−11}),(10^{−11} \leq i \leq \pi − 10^{−11})$,升交点赤经
\begin{equation}\Omega=\arccos(\frac{n_x}{n})\end{equation}
但是如果$n_y&lt;0$，那么$\Omega = 2\pi-\Omega$<br />
近地点角距
\begin{equation}\omega=\arccos(\frac{\mathbf{n}\cdot\mathbf{e}}{ne})\end{equation}
如果$e_z&lt;0$，那么$\omega = 2\pi-\omega$ <br />
真近点角
\begin{equation}\nu=\arccos(\frac{\mathbf{e}\cdot\mathbf{r}}{er})\end{equation}
如果$\mathbf{r}\cdot\mathbf{v}&lt;0$，那么$\nu=2\pi-\nu$<br />
<strong><em>情况2：对于非圆，在赤道平面的轨道</em></strong> <br />
如果$(e \geq 10^{−11}),(10^{−11} \geq i)|(i \geq \pi − 10^{−11})$，那么
\begin{equation}\Omega=0\end{equation}
\begin{equation}\omega=\arccos(\frac{\mathbf{n}\cdot\mathbf{e}}{ne})\end{equation}
但是如果$e_y&lt;0$，那么$\omega = 2\pi-\omega$ <br />
\begin{equation}\nu=\arccos(\frac{\mathbf{e}\cdot\mathbf{r}}{er})\end{equation}
如果$\mathbf{r}\cdot\mathbf{v}&lt;0$，那么$\nu=2\pi-\nu$<br />
<strong><em>情况3：对于圆，非赤道平面的轨道</em></strong><br />
如果$(e \leq 10^{−11}),(10^{−11} \leq i \leq \pi − 10^{−11})$，那么
\begin{equation}\Omega=\arccos(\frac{n_x}{n})\end{equation}
但是如果$n_y&lt;0$，那么$\Omega = 2\pi-\Omega$ <br />
\begin{equation}\omega=0\end{equation}
\begin{equation}\nu=\arccos(\frac{\mathbf{e}\cdot\mathbf{r}}{er})\end{equation}
如果$r_z&lt;0$，那么$\nu=2\pi-\nu$<br />
<strong><em>情况4：对于圆，在赤道平面的轨道</em></strong><br />
如果$(e \leq 10^{−11}),(10^{−11} \geq i)|(i \geq \pi − 10^{−11})$，那么
\begin{equation}\Omega=0\end{equation}
\begin{equation}\omega=0\end{equation}
\begin{equation}\nu=\arccos(\frac{r_x}{r})\end{equation}
如果$r_y&lt;0$，那么$\nu=2\pi-\nu$</p>

<h2 id="轨道六根数转换到笛卡尔坐标系">轨道六根数转换到笛卡尔坐标系</h2>
<ul>
  <li>已知：$a,e,i,\omega,\Omega,\nu$ 和引力常数$\mu$</li>
  <li>求： $\mathbf{r},\mathbf{v}$</li>
</ul>

<p>首先是焦准距
\begin{equation}p=a(1-e^2)\end{equation}
\begin{equation}r=\frac{p}{1+e\cos\nu}\end{equation}
\begin{equation}x=r(\cos(\omega+\nu)\cos\Omega-\cos i\sin(\omega+\nu)\sin\Omega)\end{equation}
\begin{equation}y=r(\cos(\omega+\nu)\sin\Omega+\cos i\sin(\omega+\nu)\cos\Omega)\end{equation}
\begin{equation}z=r[\sin(\omega+\nu)\sin i]\end{equation}
这个算法计算计算速度向量的前提是非抛物线轨道，也就是当($||\mathbf{p}||\geq1e-30$)，有
\begin{equation}\dot x=\sqrt\frac{\mu}{p}(\cos\nu+e)(-\sin\omega\cos\Omega-\cos i\sin\Omega\cos\omega)-\sqrt\frac{\mu}{p}\sin{\nu}(\cos\omega\cos\Omega-\cos  i\sin\Omega\sin\omega)\end{equation}
\begin{equation}\dot y=\sqrt\frac{\mu}{p}(\cos\nu+e)(-\sin\omega\sin\Omega+\cos i\cos\Omega\cos\omega)-\sqrt\frac{\mu}{p}\sin{\nu}(\cos\omega\sin\Omega+\cos i \cos\Omega\sin\omega)\end{equation}
\begin{equation}\dot z=\sqrt\frac{\mu}{p}[(\cos\nu+e)\sin i\cos\omega-\sin\nu\sin i\sin\omega]\end{equation}</p>

<hr />
<p><strong>注意这些公式带入运算时都是要化成弧度的！！！</strong></p>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 天文 </tag>
        
          <tag> 数值算法 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[红警坦克作战效能模拟平台]]></title>
      <url>/programming/2015/11/02/tank/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>编写程序使用蒙特卡洛方法以模拟计算游戏《红色警戒2》中坦克集群间交战的所有可能交换比和双方的获胜概率。通过计算，得到了一些可以修正兰彻斯特方程的结果，对指挥官的战前分析决策具有实际意义。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="兰彻斯特方程">兰彻斯特方程</h2>
<p>该理论于一战前期的1914年，由英国人弗雷德里克·威廉·兰彻斯特首先创立。
它采用数学演绎战术原则，将数学与军事战术学结合起来。兰彻斯特最先提出了一个关于空战战术的尝试性数学模型，描述作战双方兵力变化过程的数学微分方程。
这个理论属于确定性数学模型，一般认为可宏观地描述双方战斗的毁伤过程。常用于优选步兵作战兵力的投放、西方研究战争的定量、科学的常用方法。<br />
在近代战斗条件下，红、蓝两军交战，双方各自装备同类武器，相互通视，并在武器射程范围内进行直接瞄准射击；双方每一战斗单位射击对方每一战斗单位的机会大致相同。将双方在战斗中尚存的战斗单位数作为连续的状态变量，以m(t)、n(t)表示在战斗开始后t时刻蓝方、红方在战斗中尚存的作战单位数，可用下列微分方程组来描述战斗过程中双方兵力随时间的损耗关系：
\begin{equation}
\frac{dm(t)}{dn(t)} = \frac{-\beta{n(t)}}{-\alpha{n(t)}}
\end{equation}
式中α、β分别为蓝方、红方在单位时间内每一战斗单位毁伤对方战斗单位的数目， 简称为蓝方、 红方的毁伤率系数。<br />
这是一个连续的方程，它的通解形式、它的实际意义，例如平方率、线性率什么的在网上均有大量论述，这里不再陈述。</p>

<h2 id="红警的伤害机制">红警的伤害机制</h2>
<p>《红色警戒》是一款经典的RTS游戏。我们可以研究红警中的伤害机制，并编写交战模拟平台的程序，从而验证兰彻斯特方程，为交战提供策略。红警作战主要以坦克战为主，因此我们这里的研究对象也就是坦克了。<br />
红警里面有一个Rulesmd.ini文件，用来定义单位的各种属性。红警中坦克分为轻甲、中甲和重甲。武器对对方的伤害是<strong><em>杀伤力乘上对这种装甲的伤害系数</em></strong>。坦克在受到攻击后，血条便减少相应的伤害值。此外，我们在模拟平台中还要体现装弹间隔时间。红警里面部分单位还有自动回血能力，例如天启坦克、基洛夫空艇、武装采矿车等。这里以对战中的头号杀器：犀牛坦克为例，列举这些属性的值：</p>
<ul>
  <li>制造成本：900</li>
  <li>杀伤力：90</li>
  <li>对轻甲、中甲、重甲的伤害分别为：75%，100%，100%</li>
  <li>体力：400</li>
  <li>装弹间隔时间：65</li>
  <li>不具有自动回血能力</li>
</ul>

<p>编写如下的代码：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TANK</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">life</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">;</span>  <span class="c1">//攻击力
</span>    <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">once</span><span class="p">;</span>  <span class="c1">//判断临死一击
</span>    <span class="kt">int</span> <span class="n">cover</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">armor</span><span class="p">;</span>  <span class="c1">//1、 轻甲 2、中甲 3、重甲
</span>    <span class="kt">int</span> <span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TANK</span> <span class="n">tank</span><span class="p">;</span>
</code></pre></div></div>

<p>剩下的就是编写程序模拟作战过程了。以一个循环的计数器作为时间线，坦克在最初随意地寻找攻击目标，在锁定目标之后便每间隔一次装填时间完成一次对目标的进攻（以及每经过一次回血周期便恢复一定的血量）。在红警中可能会出现许多个坦克攻击同一辆坦克，导致坦克在毁灭的时刻遭受了远远大于其残余血量的伤害，这个在模拟中也要得到体现。因此，临死一击以及临死所受伤害是一个相对不太好处理的地方。程序里把常见的八种坦克的数据收录进去：灰熊坦克、犀牛坦克、天启坦克、幻影坦克、光棱坦克、遥控坦克、坦克杀手、武装采矿车，用户不用手动输入坦克的属性。根据蒙特卡洛方法的思想，对作战过程总共进行1500次模拟。</p>

<p>程序运行的截图如下所示：
<img src="http://localhost:4000/assets//blog_images/tank1.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank2.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank3.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank4.png" width="450px" height="200px" /><br />
又比如，模拟结果显示，在理想条件下，30辆犀牛坦克（红军）与25辆坦克杀手（蓝军）交战的结果为</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>交换比：  
最高1.25  
最低0.33  
平均0.64  
价值交换比：0.64  
胜率：11.67%  
零伤亡概率：0.00%  
</code></pre></div></div>
<p>在理想条件下，40辆犀牛坦克（红军）与20辆坦克杀手（蓝军）交战的结果为</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>交换比：  
最高20.00  
最低1.82  
平均3.27  
价值交换比：3.27  
胜率：100.00%  
零伤亡概率：0.00%  
</code></pre></div></div>

<h2 id="总结">总结</h2>
<ul>
  <li>可以看出，连续的兰彻斯特方程对于小数目的离散作战不能真实预测。若将5辆灰熊坦克与3辆犀牛坦克，则5辆灰熊坦克仅能勉强战胜3辆犀牛坦克。而经过实际的模拟，5辆灰熊坦克与3辆犀牛坦克交战，灰熊坦克胜率为100%，且平均只损失一辆坦克1.56辆坦克，足可见两种模型的差距</li>
  <li>若双方是相同数目的同等坦克，则双方胜率均会低于50%。如若1辆坦克对抗1辆同型号坦克，同时开火，则双方都不会获胜（双方坦克同时被摧毁）。若双方各两辆坦克对抗，则双方胜率均为26%。双方十辆坦克对抗，任一方胜率为40%.若双方45辆坦克对抗，则任一方胜率为48%.由此可见，坦克的数目越大，可能出现的情况就越多，出现平局的可能性就越小</li>
  <li>许多人认为成群的光棱海无法击破，实际上单一的光棱坦克没有别的坦克配合的话很难与犀牛坦克群的阵型冲击、天启坦克的重火力重护甲、矿车的重护甲高射速抗衡。尽管光棱坦克射程极远，但没有幻影坦克配合，无法直接正面参与坦克战</li>
  <li>一般而言，人们常常喜欢集中优势兵力攻打某个单位，这种战术在特殊情况下是错误的。例如天启坦克群与别的坦克群交战，天启坦克依靠重火力有很大的胜算，但是如果所有天启坦克集中火力攻击一辆坦克，这样反而浪费炮弹</li>
  <li>这里没有考虑兵种配合的问题。如在坦克阵中假如与之配合的步兵（尤其是反坦克步兵），则既能吸引敌方火力向步兵开火，又能给以敌方杀伤</li>
  <li>作为一个资深红警玩家<strong><em>（2017年更新，早就不玩了）</em></strong>，也知道这个模拟平台还是有不完善的地方。在真实的红警坦克战里，如果考虑操作，那么坦克攻击范围、移动速度、炮塔转动角度、是否能够移动攻击都会造成非常大的影响，更不用提什么分兵战术、迂回战术等。而且这里没有考虑到光棱坦克的溅射伤害和幻影坦克的隐蔽性，还有作战单位升级的情况</li>
  <li>事实上，对于真正的坦克战而言，机动性、射程、移动攻击能力、阵型、布坦协同都是十分重要的，而我的程序模拟的是定点攻击，这实际上与火炮别无两样。坦克需要发挥其阵型冲锋、冲锋打散阵型、移动攻击等机动性优势，例如犀牛坦克常常强势冲锋等战术，这是程序无法模拟的。因此，程序仅仅能提供一个基本的战术参考，这替代不了指挥官的战术决策</li>
  <li>2017年更新：现在看自己以前写的代码感觉是真的丑陋，不过这也说明了自己的代码水平还是有一丢丢进步的:grin:</li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 兰彻斯特方程 </tag>
        
          <tag> 蒙特卡洛方法 </tag>
        
          <tag> C语言 </tag>
        
          <tag> 作战效能模拟 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Download this Theme]]></title>
      <url>/2015/06/24/download-this-theme/</url>
      <content type="html"><![CDATA[<p><strong><em>Fork</em></strong> or <strong><em>download</em></strong> the theme <a href="https://github.com/Jackpon/Jackpon.github.io">here on GitHub</a>.</p>
]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
