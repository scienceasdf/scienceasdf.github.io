<?xml version="1.0" encoding="utf-8"?>
<search>
  
    <entry>
      <title><![CDATA[在手机上绘制根轨迹]]></title>
      <url>/programming/2017/11/15/easyauto/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>写了一个能够绘制线性系统根轨迹、响应曲线、计算幅值裕度、相位裕度等的手机APP。下载地址在文末。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="算法">算法</h2>
<h3 id="各种裕度的计算">各种裕度的计算</h3>
<p>很简单，就是用弦截法计算各种穿越频率，然后计算裕度。具体的代码以及API设计可以见GitHub，不过弦截法
需要给出猜测初值，在手机里这个程序也就只能在几个初值里面试，如果这个初值迭代不收敛就换另一个初值
。目前的算法能够通过所有我写的测试用例，不过不知道是否有不对的情况。</p>
<h3 id="与绘制各种根轨迹相关的算法">与绘制各种根轨迹相关的算法</h3>
<h4 id="多项式求根算法">多项式求根算法</h4>
<p>非常美妙的事情是，NDK虽然是个大坑，不过Eigen库还是能够使用的。
多项式的求根可以转化为它的companion matrix的特征值问题来求解：$p(t)=c_{0}+c_{1}t+\cdots +c_{n-1}t^{n-1}+t^{n}$的companion matrix是<br />
<script type="math/tex">% <![CDATA[
\begin{equation} \tag{a}
C(p)=\begin{bmatrix}
0 & 0 & \dots & 0 & -c_{0}\\
1 & 0 & \dots & 0 & -c_{1}\\
0 & 1 & \dots & 0 & -c_{2}\\
\vdots & \vdots & \ddots & \vdots & \vdots \\
0 & 0 & \dots & 1 & -c_{n-1}
\end{bmatrix}
\end{equation} %]]></script>
这样就可以将多项式求根问题转化为矩阵的特征值问题，然后利用Eigen库求解。</p>
<h4 id="排序算法">排序算法</h4>
<p>由于Eigen求出特征值是无序的，而绘图时是按照方程的根的离散点连线绘制，因此可能会造成各条轨迹交织的情况。为了避免这种情况，需要对根进行排序，即这组点到上组点的距离分别最近进行排序。
这个没有想到更好的点子，实现的算法复杂度为$O(n^2)$，但是在手机上没有卡过，代码如下：</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">matsz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">){</span>
 <span class="err"> </span> <span class="err"> </span><span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">*</span><span class="n">std</span><span class="o">::</span><span class="n">min_element</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">i</span><span class="p">,</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
 <span class="err"> </span> <span class="err"> </span><span class="p">[</span><span class="o">&amp;</span><span class="n">i</span><span class="p">](</span><span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">complex</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">b</span><span class="p">)</span> <span class="err"> </span> 
 <span class="err"> </span> <span class="err"> </span><span class="c1">// static variables don't need to be captured
</span>    <span class="p">{</span><span class="k">return</span> <span class="n">norm</span><span class="p">(</span><span class="n">a</span> <span class="o">-</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">&lt;</span> <span class="n">norm</span><span class="p">(</span><span class="n">b</span> <span class="o">-</span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]);}));</span>
 <span class="err">  </span> <span class="n">pre</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">res</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
<span class="p">}</span>
</code></pre></div></div>

<h3 id="计算响应的算法">计算响应的算法</h3>
<p>这个一开始想用矩阵的幂来进行计算，但是发现许多时候线性系统的$\mathbf{A}$矩阵都是奇异的，没办法，
还是只能用RK45算法，好在现在手机处理器性能很强，没有任何卡的迹象</p>

<h2 id="处理用户输入">处理用户输入</h2>
<p>为了让用户能够有更好的交互体验，设计的输入格式比较宽送。处理用户输入用了Boost::tokenizer库，这是
一个Header-only的库，不需要编译（当然我也自己编译了Boost库，除了Math库编译不了，别的都可以编译，
具体能不能用还没有认真试过）。NDK真的是一个大坑，GOOGLE官方对GCC值支持到GCC4.9，然而Qt for Android是GCC编译的，而GCC4.9对C++14支持不全不说，有的C++11的东西都没法用，比如std::stod,std::to_string，所以先自己实现一个。。。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#ifdef FOR_MOBILE
</span><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>

    <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">to_string</span><span class="p">(</span><span class="n">T</span> <span class="n">value</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">ostringstream</span> <span class="n">os</span> <span class="p">;</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="p">;</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">.</span><span class="n">str</span><span class="p">()</span> <span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">//template &lt;typename T&gt;
</span>    <span class="kt">double</span> <span class="n">stod</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">double</span> <span class="n">res</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">istringstream</span> <span class="p">(</span> <span class="n">str</span> <span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="n">res</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
    <span class="p">}</span>

<span class="p">}</span>
<span class="cp">#endif
</span></code></pre></div></div>
<p>用户的输入可以是这样的格式：“1 2 3 * -3 1 * 2,-1*2,-1 0”，通常用户的输入都是以各个零极点为根的多项式之积，*是各个相乘多项式之间的分隔符, 而空白和英文逗号可以作为多项式中各个系数
 之间的分隔符，表示的多项式就是(s<sup>2</sup>+2s+3)(-3s+1)(2s-1)(2s<sup>2</sup>-s).于是采用Boost::tokenizer将字符串进行两层分割：第一层是乘法运算符*，第二层则是空格和英文逗号。</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="cp">#include &lt;boost/tokenizer.hpp&gt;
</span>
 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">poly</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">myString</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">res</span><span class="p">;</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sep</span><span class="p">(</span><span class="s">" ,"</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tok</span><span class="p">(</span><span class="n">myString</span><span class="p">,</span><span class="n">sep</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">beg</span><span class="o">=</span><span class="n">tok</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">beg</span><span class="o">!=</span><span class="n">tok</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">beg</span><span class="p">){</span>
        <span class="n">res</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stod</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">));</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">reverse</span><span class="p">(</span><span class="n">res</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span><span class="n">res</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>

 <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">polyFromRawText</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">rawText</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">res</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">sep</span><span class="p">(</span><span class="s">"*"</span><span class="p">);</span>
    <span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;</span> <span class="n">tok</span><span class="p">(</span><span class="n">rawText</span><span class="p">,</span><span class="n">sep</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">tokenizer</span><span class="o">&lt;</span><span class="n">boost</span><span class="o">::</span><span class="n">char_separator</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;&gt;::</span><span class="n">iterator</span> <span class="n">beg</span><span class="o">=</span><span class="n">tok</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">beg</span><span class="o">!=</span><span class="n">tok</span><span class="p">.</span><span class="n">end</span><span class="p">();</span><span class="o">++</span><span class="n">beg</span><span class="p">){</span>
        <span class="k">auto</span> <span class="n">vec</span> <span class="o">=</span> <span class="n">poly</span><span class="p">(</span><span class="o">*</span><span class="n">beg</span><span class="p">);</span>
        <span class="n">res</span> <span class="o">=</span> <span class="n">convolution</span><span class="p">(</span><span class="n">res</span><span class="p">,</span><span class="n">vec</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">res</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<p>这段代码的作用是将用户输入分割，并且返回成一个多项式。在这里我自己实现了一个多项式的std::vector<double>用来表示多项式的系数，并实现乘法运算convolution，并且在线性系统的类中也有两个多项式成员：传递函数的分子和分母。  
 实际上使用Boost::tokenizer是一种比较简单可行的方式，也可以用Boost::splitter或者用正则表达式匹配甚至直接自己写一个简单parser都可以实现功能。</double></p>

<h2 id="多项式的富文本输出">多项式的富文本输出</h2>
<p>为了让用户直观地知道输入的格式代表的多项式，应该在QLabel中将多项式以富文本的形式输出，而且应该<strong><em>同时输出多项式相乘和多项式展开的形式</em></strong>，这里多项式输出时为了追求完美，符合平时的习惯，应该特别注意系数为0,1以及正负号的问题。具体代码太长，见GitHub仓库。</p>
<h2 id="截图">截图</h2>
<p><img src="http://localhost:4000/assets//blog_images/shot1.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/shot2.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/shot3.png" width="350px" height="200px" /></p>
<h2 id="其他">其他</h2>
<ul>
  <li>这个APP的创意出自我的室友，他觉得每次做完自动控制原理的题之后又要打开电脑开MATLAB去检验非常麻烦，这个APP就能够解决这样的问题</li>
  <li>APP中绘制根轨迹的增益K是用户输入的，而且绘图时是从0到K线性地取1000个点进行计算绘制，这样的效果并不一定是最好的。在MATLAB中绘制根轨迹的增益取值算法值得借鉴</li>
  <li>本来用的是QCustomPlot来绘制曲线的，结果这个东西在手机上的渲染效果很差，于是改成了
QtCharts，发现这个模块优点很多，而且在手机上显示的效果很好</li>
  <li>虽然GOOGLE的NDK非常坑，不过有一个替代方案据说还是不错的：Crystax NDK，不过自从2017年就没有发布新版本了，社区也不太活跃（GitHub上的代码倒还在改）</li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 自动控制 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[太阳高度角与方位角的计算]]></title>
      <url>/programming/2017/10/22/soalrAngle/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨太阳高度角与方位角的计算，并写了个手机程序用于计算此时此刻此地（也可以是任意时刻，任意地点）的太阳高度角与方位角.</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="基本算法">基本算法</h2>
<p>就是一大堆玄学（或者叫天文学）的概念了。</p>
<h3 id="当地正午时间">当地正午时间</h3>
<p>给定经度$\Phi$（都假设是东经，主要研究中国国土范围内的问题），那么当地的正午时间在北京时间下的时间可以表示成：（这个感觉用代码比公式更加直观）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">timeType</span> <span class="nf">getNoonTime</span><span class="p">(</span><span class="kt">double</span> <span class="n">longitude</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// assume in the eastern semi-sphere
</span>    <span class="c1">// expressed in UTC+8 time
</span>    <span class="c1">//longtitude expressed in degrees
</span>    <span class="kt">int</span> <span class="n">dt</span><span class="o">=</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="p">(</span><span class="mi">4</span><span class="o">*</span><span class="p">(</span><span class="mf">120.0</span><span class="o">-</span><span class="n">longitude</span><span class="p">));</span>
    <span class="n">timeType</span> <span class="n">t1</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">t1</span><span class="o">+=</span><span class="n">dt</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">t1</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="太阳时角">太阳时角</h3>
<p>太阳时角是指日面中心的时角，即从观测点天球子午圈沿天赤道量至太阳所在时圈的角距离。计算公式为
\begin{equation}
h=15\times (ST-12)
\end{equation}
$ST$为真太阳时。然而平常我们通常都使用北京时间，因此太阳时角的计算公式如下：（还是代码比公式直观）</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">double</span> <span class="nf">getHourAngle</span><span class="p">(</span><span class="kt">double</span> <span class="n">longitude</span><span class="p">,</span> <span class="k">const</span> <span class="n">timeType</span><span class="o">&amp;</span> <span class="n">t1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// The results return the angle expressed in degrees
</span>    <span class="c1">// also UTC+8
</span>    <span class="n">timeType</span> <span class="n">t2</span><span class="o">=</span><span class="n">getNoonTime</span><span class="p">(</span><span class="n">longitude</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">dt</span><span class="o">=</span><span class="n">t1</span><span class="o">-</span><span class="n">t2</span><span class="p">;</span>
    <span class="k">return</span> <span class="mf">.25</span><span class="o">*</span><span class="n">dt</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>
<h3 id="太阳赤纬">太阳赤纬</h3>
<p>太阳赤纬，是地球赤道平面与太阳和地球中心的连线之间的夹角。赤纬角以年为周期，在+23 °26′与-23 °26′的范围内移动，成为季节的标志。最简单的方法是将
赤纬的变化考虑为线性变化。在一篇参考文献上，给出了更为近似的计算方式：按照三角函数变化规律计算。我在这里也按照这种方式计算。而百度百科还给出了一
个更加精确的公式:
\begin{equation} \label{preci}
\delta=0.006918-0.399912 \cos (b)+0.070257 \sin (b)-0.006758 \cos (2b)+ 0.000907\sin (2b)-0.002697\cos (3b)+0.00148\sin (3b)
\end{equation}
其中</p>
<ul>
  <li>$\delta$的单位为度(deg)；</li>
  <li>$\pi$=3.1415926为圆周率；</li>
  <li>$b=2\pi (N-1)/365$，单位为弧度；</li>
  <li>$N$为日数，自每年1月1日开始计算。  <br />
有空去把程序改成这个公式再去跑跑。</li>
</ul>

<h3 id="太阳高度角的计算">太阳高度角的计算</h3>
<p>\begin{equation}
\sin \theta_\mathrm{s} = \cos h \cos \delta \cos \Phi + \sin \delta \sin \Phi \,,
\end{equation}
此处</p>
<ul>
  <li>$\theta_\mathrm{s}$是太阳高度角，</li>
  <li>$h$是以地方恒星时系统下的时角，</li>
  <li>$\delta$是目前的太阳赤纬，</li>
  <li>$\Phi$是当地的纬度。</li>
</ul>

<h3 id="太阳方位角的计算">太阳方位角的计算</h3>
<p>在维基百科上查到的是如下的近似公式
\begin{equation}
\cos \phi _\mathrm {s}=\frac {\sin \delta -\sin \theta _\mathrm {s}\sin \Phi }{cos\theta _\mathrm {s}\cos \Phi }
\end{equation}</p>

<h2 id="程序相关">程序相关</h2>
<p>前面的代码也可以看出，这个问题需要自己实现时间类timeType和日期类dateType，包括一些基本的运算操作，不过也可以用Boost库的或者用Qt的。编程的时候需要特别小心角度与弧度的换算。在安卓程序中需要实现对设备的经纬度定位，还是要感谢Qt，让一切变得十分方便。
类Widget作为主窗体，定义如下：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">class</span> <span class="nc">Widget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">QWidget</span>
<span class="p">{</span>
    <span class="n">Q_OBJECT</span>

<span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Widget</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span> <span class="o">=</span> <span class="mi">0</span><span class="p">);</span>
    <span class="o">~</span><span class="n">Widget</span><span class="p">();</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">Ui</span><span class="o">::</span><span class="n">Widget</span> <span class="o">*</span><span class="n">ui</span><span class="p">;</span>

    <span class="n">QGeoPositionInfoSource</span> <span class="o">*</span><span class="n">source</span><span class="p">;</span>

<span class="k">public</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span> <span class="n">info</span><span class="p">);</span>
<span class="k">private</span> <span class="n">slots</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">on_updateButton_clicked</span><span class="p">();</span>
<span class="p">};</span>
</code></pre></div></div>
<p>具体定位的代码如下：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Widget</span><span class="o">::</span><span class="n">Widget</span><span class="p">(</span><span class="n">QWidget</span> <span class="o">*</span><span class="n">parent</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">QWidget</span><span class="p">(</span><span class="n">parent</span><span class="p">),</span>
    <span class="n">ui</span><span class="p">(</span><span class="k">new</span> <span class="n">Ui</span><span class="o">::</span><span class="n">Widget</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">flag</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">QGeoPositionInfoSource</span><span class="o">*</span> <span class="n">source2</span> <span class="o">=</span> <span class="n">QGeoPositionInfoSource</span><span class="o">::</span><span class="n">createDefaultSource</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">source2</span><span class="p">){</span>
        <span class="n">source2</span><span class="o">-&gt;</span><span class="n">setUpdateInterval</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
        <span class="n">connect</span><span class="p">(</span><span class="n">source2</span><span class="p">,</span> <span class="n">SIGNAL</span><span class="p">(</span><span class="n">positionUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span><span class="p">)),</span><span class="k">this</span><span class="p">,</span> <span class="n">SLOT</span><span class="p">(</span><span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span><span class="p">)));</span>
        <span class="n">source2</span><span class="o">-&gt;</span><span class="n">startUpdates</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span><span class="p">{</span>
        <span class="n">flag</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="c1">// ...
</span><span class="p">}</span>

<span class="kt">void</span> <span class="n">Widget</span><span class="o">::</span><span class="n">realtimeUpdated</span><span class="p">(</span><span class="n">QGeoPositionInfo</span> <span class="n">info</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">double</span> <span class="n">latitude</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">coordinate</span><span class="p">().</span><span class="n">latitude</span><span class="p">();</span>
    <span class="kt">double</span> <span class="n">longitude</span> <span class="o">=</span> <span class="n">info</span><span class="p">.</span><span class="n">coordinate</span><span class="p">().</span><span class="n">longitude</span><span class="p">();</span>

    <span class="n">QTime</span> <span class="n">time1</span> <span class="o">=</span> <span class="n">QTime</span><span class="o">::</span><span class="n">currentTime</span><span class="p">();</span>
    <span class="n">timeType</span> <span class="n">td1</span><span class="p">(</span><span class="n">time1</span><span class="p">.</span><span class="n">hour</span><span class="p">(),</span><span class="n">time1</span><span class="p">.</span><span class="n">minute</span><span class="p">());</span>

    <span class="n">QDate</span> <span class="n">d1</span> <span class="o">=</span> <span class="n">QDate</span><span class="o">::</span><span class="n">currentDate</span><span class="p">();</span>

    <span class="kt">double</span> <span class="n">timeAngle</span><span class="o">=</span><span class="n">getHourAngle</span><span class="p">(</span><span class="n">longitude</span><span class="p">,</span><span class="n">td1</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">elevAngle</span><span class="o">=</span><span class="n">getSolarElevationAngle</span><span class="p">(</span><span class="n">getSolarDeclination</span><span class="p">(</span><span class="n">d1</span><span class="p">),</span><span class="n">latitude</span><span class="p">,</span><span class="n">timeAngle</span><span class="p">);</span>
    <span class="kt">double</span> <span class="n">azimuth</span><span class="o">=</span><span class="n">getSolarAzimuthAngle</span><span class="p">(</span><span class="n">getSolarDeclination</span><span class="p">(</span><span class="n">d1</span><span class="p">),</span><span class="n">latitude</span><span class="p">,</span><span class="n">timeAngle</span><span class="p">,</span><span class="n">elevAngle</span><span class="p">);</span>
	<span class="c1">// ...
</span><span class="p">}</span>
</code></pre></div></div>

<h2 id="应用">应用</h2>
<ul>
  <li>和Stellarium里面的太阳高度角、方位角进行了对比，虽然在这里的计算中有些是近似公式，但是误差也不会超过1°</li>
  <li>这个程序，这种方法让我在外地，只要有晴天，就能找到东西南北</li>
  <li>这个程序还可以应用于一些太阳能实验上，如太阳能飞机的动力试车，大概选在哪些月份，哪些时刻，或者说如何调整电池片的方向以使电池片接收到最多的太阳光强能够心里有数</li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 天文 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈螺旋桨航模（无人机）的动力系统选配（二）]]></title>
      <url>/programming/2017/08/17/propulsion2/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨了螺旋桨无人机动力系统的相关理论，并开发手机与电脑版程序解决相关问题。下载地址在文末。</strong></p>

<hr />
<p>上一篇文章我们讲了螺旋桨无人机动力系统相关的理论，这篇文章说说程序的设计。</p>

<h2 id="数据来源">数据来源</h2>
<p>所有的数据都来自于APC官网的数据。由于APC螺旋桨高效率的优点（正品APC桨的效率非常高，接近0.9），以及APC在其官网公布了所有型号的理论性能数据文件，故下载所有其官网上的五百个左右性能数据文件，其文件已经存储为固定的格式。先在官网上下载索引文件PER2_TITLEDAT.txt，再用wget批量将所有的螺旋桨性能数据文件下载下来。一共五百来个文件，中间下载是否有连接错误导致文件没有下载完整我也不知道(捂脸）。APC的桨型号很齐全，基本覆盖了航模级别常用的尺寸，从几英寸到26英寸的都有，如果在这些型号以外的型号那就没办法了。。。数据全部都是dat格式的，用std::ifstream读文件非常耗时。对于开发的安卓版本，肯定不会用External folder里面包含所有的数据，只能用Qt资源文件+QDataStream来读写（不支持std::ifstream)，这样速度更快，不过缺点在于如果数据变动、扩展会不太方便。在写完所有程序之后，我还把所有数据迁移到了一个sqlite数据库文件中，并加上索引，访问速度大大提升，不过目前是不想重构sqlite的版本了。</p>

<h2 id="功能介绍">功能介绍</h2>
<p>程序分为PC版和移动（安卓）版，主要以介绍PC版为主。PC版共有两个程序：DemoProp，用于计算无刷电机动力系统的工作状况并给出一定的建议；PropChart，用于计算电动和油动动力系统的工作状况并绘制图表。</p>
<h3 id="筛选功能">筛选功能</h3>
<p>程序可以对给定的工作状况下的符合要求（如拉力、效率等条件）的螺旋桨进行筛选。DemoProp的筛选界面如下图所示，可以输入电机、电源、减速组等相关信息。
<img src="http://localhost:4000/assets//blog_images/fig2.png" width="350px" height="200px" />
PropChart的筛选界面如下图所示，这里运用的模型是给定转速或者给定输入功率，这样就既能够用于求解电动系统的工作状况，也适用于求解油动系统的工作状况。
<img src="http://localhost:4000/assets//blog_images/fig4.png" width="350px" height="200px" /></p>

<h3 id="分析功能">分析功能</h3>
<p>DemoProp能够对具体的电动系统选配提出指导意见，可以判断当前电机、电源、螺旋桨、减速组的组合究竟是轻载、超载还是正常载荷，如下图所示。
<img src="http://localhost:4000/assets//blog_images/fig3.png" width="350px" height="200px" /></p>

<h3 id="图表功能">图表功能</h3>
<p>PropChart能够绘制螺旋桨的拉力曲线、效率曲线等等，这里我用的是QCustomPlot进行绘制，如下图所示。
<img src="http://localhost:4000/assets//blog_images/fig5.png" width="350px" height="200px" /></p>

<h3 id="移动版">移动版</h3>
<p>一直苦于在室外进行动力试验的时候，不方便将测量的数据与仿真数据进行校对、不知道动力系统应该怎么调整。感谢伟大的Qt的跨平台特性，让我能够将程序移植到安卓系统上（实际上移植到iOS上也可以，不过就是我没有苹果电脑与手机），极大地方便了在外场的实验。针对手机的一些特点，在功能上进行了一些改进，例如取消筛选功能，并增加绘制能量分析饼图的功能。手机版的交互体验应该比电脑版的好太多了。截图如下：
<img src="http://localhost:4000/assets//blog_images/scr2.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/scr3.png" width="350px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/scr1.png" width="350px" height="200px" /></p>
<h2 id="数据验证">数据验证</h2>
<h3 id="静拉力实测数据验证">静拉力实测数据验证</h3>
<p>测试仿APC12X6E螺旋桨,飓风2820电机，$K_v=920$
，内阻28mOhm，静拉力1.7千克力，电流47-48安，转速8300RPM。仿真结果为静拉力2.3千克力，转速8830RPM。考虑到APC官网的数据本来比实际值偏高（参考文献的风洞实验数据有验证），误差与使用偏高值以及没有使用正品APC螺旋桨有关。</p>
<h3 id="应用于太阳能飞机动力系统的例子">应用于太阳能飞机动力系统的例子</h3>
<p>某翼展为5米的太阳能无人机，没有储能装置，太阳能提供动力系统的所有能量。机翼上的电池片大约提供110瓦电能。实验测试测得电池片能够提供的电压大约不超过13V，电流不超过8A。最早使用KV值1000的电机驱动20英寸的自制螺旋桨，静拉力输出很难超过1千克力。换用340KV电机带20英寸以上的木桨，静拉力能够超过10千克力。经计算表明，电机KV值在200附近时驱动20$\sim$22英寸螺旋桨能够有更高效率，换用200KV螺旋桨，以及APC22X10E的螺旋桨，静拉力为1.35千克力。</p>
<h2 id="存在的问题">存在的问题</h2>
<ul>
  <li>筛选功能卡在IO上比较耗时间。当然，MSVC编译的程序能够明显快于MINGW编译的程序。解决方法有很多，只是我不想去重构了</li>
  <li>电脑版的交互体验非常差</li>
  <li>
    <h2 id="电脑版没有对ui进行多分辨率的调整">电脑版没有对UI进行多分辨率的调整</h2>
    <p><a href="https://pan.baidu.com/s/1QaN9CxFEfJz0RHewitcCgg">安卓版程序下载地址</a><br />
<a href="https://pan.baidu.com/s/1W5DtxZFxC6SmjRxvO9F_tA">Windows版程序下载地址（32位）</a></p>
  </li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 无人机 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[浅谈螺旋桨航模（无人机）的动力系统选配（一）]]></title>
      <url>/programming/2017/08/17/propulsion1/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]},
  							TeX: { equationNumbers: {  autoNumber: "AMS"  },
     							   extensions: ["AMSmath.js"]}
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>探讨了螺旋桨无人机动力系统的相关理论，并开发手机与电脑版程序解决相关问题。下载地址在文末。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="动力系统的数学模型">动力系统的数学模型</h2>
<h3 id="无刷电机的数学模型">无刷电机的数学模型</h3>
<p>有<br />
<script type="math/tex">\begin{equation} \label{eqs:1} \tag{a}
\left \{
\begin{array}{l}
U=r_a I+\frac{n}{K_v}\\
I=\frac{M_{em}}{K_m}
\end{array}
\right.
\end{equation}</script>
其中，$r_a$为电机内阻，$U$为电机两端电压，$I$为通过电机的电流，$K_v$为电机Kv值，$K_m$为电机转矩常数，$n$为电机转速(RPM)，$M_{em}$是电机的电磁转矩。<br />
电机的输出转矩为
\begin{equation}
M_{mot}=M_{em}-M_{R}=k_m(I-I_0)
\end{equation}
$K_v$的量纲为RPM/V，$K_m$的量纲是N$\cdot$m/A，在国际单位制下电机的$K_v$与$K_m$满足关系
\begin{equation}
K_m=\frac{60}{2\pi K_v }
\end{equation}
电机的输入功率为
\begin{equation}
P_{in}=UI
\end{equation}
输出功率为
\begin{equation}
P_{out}=\frac{2\pi nM_{mot}}{60}
\end{equation}
电机的效率为
\begin{equation}
%\eta=\frac{P_{out}}{P_{in}}=\frac{2\pi nM_{mot}}{60UI}
\eta =\frac{P_{out}}{P_{in}}=\frac{2\pi nM_{mot}}{60UI}
\end{equation}</p>

<h3 id="螺旋桨的数学模型">螺旋桨的数学模型</h3>
<p>对于螺旋桨，转矩$M$、拉力$T$、功率$P$、效率$\eta$都是空速$v$、螺旋桨转速$n$的函数
<script type="math/tex">\begin{equation} \label{basics} \tag{b}
\left\{
\begin{array}{l}
M=M(v,n)\\
T=T(v,n)=C_T(v,n)\cdot\rho n^2 D^4\\
P=P(v,n)=C_P(v,n)\cdot\rho n^3 D^5\\
\eta=\eta(v,n)
\end{array}
\right.
\end{equation}</script><br />
$C_T$是拉力系数、$C_P$是功率系数，且有$P=M\cdot\frac{2\pi n}{60}$，$\eta=\frac{Tv}{P}$。
定义一个无量纲参数进动比(advance ratio)
\begin{equation} J=\frac{v}{nD}\end{equation}
$D$为螺旋桨直径。通常，$\eta$与$J$的变化关系如图所示。在进行初步分析的手工计算中，可以认为$J$
是一个相似性判定的参数，如果同一螺旋桨，工作在1状况$(v_1,n_1)$与2状况$(v_2,n_2)$，满足进动比相同，即
$\frac{v_1}{n_1}=\frac{v_2}{n_2}$，则可以认为工作状况下的效率$\eta$、拉力系数$C_T$、功率系数$C_P$均相同。如果要估算某一工作状况
$(v,n)$的工作参数，仅需先计算进动比$J=\frac{v}{nD}$，然后查找对应进动比的相关$\eta,C_T\text{和}C_P$，然后按照式(\ref{basics})
计算拉力、转矩、效率与功率。
<img src="http://localhost:4000/assets//blog_images/fig1.png" width="350px" height="200px" />
实际上，由于低雷诺数的影响，对于进动比相同的两种工作状况，$\eta,C_T\text{和}C_P$并不一定对应相等。通常高雷诺数的工作状况下螺旋桨的工作效率更高。</p>
<h3 id="电源模型">电源模型</h3>
<p>通常，无人机上使用的电源为蓄电池。蓄电池电源的伏安特性关系为：
\begin{equation} \label{eqs:src1}
U=U_0-Ir_0 <br />
\end{equation}
其中$r_0$为蓄电池内阻。
 对于太阳能无人机，通常是太阳能电池直接为蓄电池充电，由蓄电池驱动直流电机，那么电机两端的电压电流关系满足式(\ref{eqs:src1}).而若太阳能无人机有特殊的要求(如某些太阳能飞机竞赛),那么设计的飞机会是太阳能电池片组直接为动力系统供电。太阳能电池片组的伏安特性关系为
\begin{equation}\label{solar_array} 
I=I_{sc}[1-A(e^{U/BU_{oc}})-1]
\end{equation}
其中，<script type="math/tex">A=(1-\frac{I_m}{I_{sc}})e^{-U_m/(BU_{oc})}</script><br />
<script type="math/tex">B=(\frac{U_m}{U_{oc}}-1)[\ln(1-\frac{I_m}{I_{sc}})]</script><br />
$I_{sc}$为电池组的短路电流;<br />
$U_{oc}$为电池组的开路电压;<br />
$U_m,I_m$为最大功率点处的太阳能电池的输出电压与电流.</p>

<h3 id="综合模型及其求解">综合模型及其求解</h3>
<p>已知飞机的飞行速度$v$，无刷电机的$K_v$值，内阻$r_a$与10V下空载电流$i_0$，以及螺旋桨对应的性能数据，则利用电机转矩等于螺旋桨转矩的关系，求解在电压与电流下的转速$n$，其它参数则可对应求解。电源的电压和电流可以符合某种伏安特性曲线,如式(\ref{eqs:src1})、(\ref{solar_array})，求解过程则为弦截法对转速迭代求解。电源也可能是具有限流或限压值，也可以给出电源电压与电流的上限，求解时取转速上限恰好同时满足不超过电源电压与电流的上限。</p>
<h3 id="非平凡模型">非平凡模型</h3>
<h4 id="引入减速组">引入减速组</h4>
<p>设减速组减速比为$K$，机械效率为$\eta_g$，则有<br />
<script type="math/tex">\begin{equation}
\left\{
\begin{array}{l}
n_{prop}=\frac{n_{mot}}{K}\\
T_{prop}=K\cdot T_{mot}\cdot\eta_g
\end{array}
\right.
\end{equation}</script><br />
考虑$\eta_g=1$的理想减速器，与电机形成的系统可以等效为一个$K_v$值折合为原电机$K_v$值$\frac{1}{K}$
的新电机。通常高效率螺旋桨的特征都是低负载、大直径、大桨距（相对于直径）、低速运行，所以为了动力系统的效率最大化应该用大直径螺旋桨。由于带动大直径螺旋桨所需的转矩大，如果需要使电机工作在最大电流以下，可以使用减速组或使用低$K_v$值的电机。然而低$K_v$值得电机内阻会比高$K_v$值得电机内阻大，使用减速组会有机械能损失。而且大直径螺旋桨的重量大，且能驱动大直径螺旋桨的电机或减速器通常重量也较大。故具体应选用的方案，应考虑效率、重量、成本、加工装配难度等多方面考虑。</p>

<h4 id="单电机驱动两个螺旋桨">单电机驱动两个螺旋桨</h4>
<p>在这种情况下，有<br />
<script type="math/tex">\begin{equation} \label{eqs:12} \tag{c}
\left\{
\begin{array}{l}
n_{prop}=n_{mot}\\
M_{prop}=\frac{M_{mot}}{2}
\end{array}
\right.
\end{equation}</script>
求解上式则可以求出电机的转速。双电机驱动单螺旋桨及其它类似情况可以按照类似的方法列出公式求解。</p>
<h3 id="内燃机的特性">内燃机的特性</h3>
<p>无人机上使用的内燃机通常可分为两行程发动机和四行程发动机。两行程发动机与四行程发动机相比，优点是功率大，可动零件少，维护简便，价格便宜；缺点是油料燃烧不充分，燃料消耗大。两行程发动机还有两个显著特点：</p>
<ul>
  <li>使用这类发动机的无人机，爬升时经常可以听到转速明显下降的声音，俯冲时可以明显听到转速明显升高的声音，原因是这种发动机的扭矩小，对负载的变化较敏感。为了减小这种影响，两行程发动机一般使用大直径小桨距螺旋桨。</li>
  <li>两行程发动机转速普遍较高，也只有在高速下才能发挥出全部功率，所以厂家提供的功率数据也是要达到一定转速。二行程发动机最大的缺点是油门非线性。</li>
</ul>

<p>四行程发动机的优点是油门线性好，扭矩大，转速稳定，声音柔和，可以使用大桨距的螺旋桨，提高效率。四行程发动机工作室燃料燃烧充分。无人机爬升时，转速稳定、爬升有力、声音无变化。而四行程的缺点是价格昂贵，重量较大，维护不便。同样的工作容积，普通的四行程发动机输出功率理论上只有两行程发动机的一半，但是实际上不同于二行程发动机，四行程发动机的最大输出功率是在一般使用中可以达到要求的转速范围内的。<br />
由参考文献,对于高亚音速的飞机，内燃机的功率会随着速度的增加而增大；而对于大多数慢速飞机，内燃机的功率可以认为不变。大多数无人机的巡航速度下发动机的功率可以认为近似不变，那么对应其最大输出功率、最大输出转矩，通常需要一个合适的转速，否则发动机性能无法得到最大发挥。</p>

<hr />
<p><a href="https://pan.baidu.com/s/1QaN9CxFEfJz0RHewitcCgg">安卓版程序下载地址</a><br />
<a href="https://pan.baidu.com/s/1W5DtxZFxC6SmjRxvO9F_tA">Windows版程序下载地址（32位）</a><br />
由于博文过长会导致浏览器加载、渲染速度降低，故后续讨论请看下一篇文章。</p>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 无人机 </tag>
        
          <tag> 安卓开发 </tag>
        
          <tag> Qt </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[红警坦克作战效能模拟平台]]></title>
      <url>/programming/2015/11/02/tank/</url>
      <content type="html"><![CDATA[<script type="text/x-mathjax-config">
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: "AMS"  
                },
     		    extensions: ["AMSmath.js"]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            "HTML-CSS": { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
		</script>

<script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

<p><strong>兰彻斯特方程作为一个连续函数的微分方程组，用于计算战场交换比。因为实际应用中双方单位数目为自然数，离散而不连续，所以编写了相应的程序使用蒙特卡洛方法以模拟计算游戏《红色警戒2》中坦克集群间交战的所有可能交换比和双方的获胜概率。通过计算，得到了一些可以修正兰彻斯特方程的结果，对指挥官的战前分析决策具有实际意义。</strong></p>

<hr />
<p><strong>本文公式较多，在浏览器中将会花较长时间用于渲染公式。</strong></p>

<hr />

<h2 id="兰彻斯特方程">兰彻斯特方程</h2>
<p>该理论于一战前期的1914年，由英国人弗雷德里克·威廉·兰彻斯特首先创立。
它采用数学演绎战术原则，将数学与军事战术学结合起来。兰彻斯特最先提出了一个关于空战战术的尝试性数学模型，描述作战双方兵力变化过程的数学微分方程。
这个理论属于确定性数学模型，一般认为可宏观地描述双方战斗的毁伤过程。常用于优选步兵作战兵力的投放、西方研究战争的定量、科学的常用方法。<br />
在近代战斗条件下，红、蓝两军交战，双方各自装备同类武器，相互通视，并在武器射程范围内进行直接瞄准射击；双方每一战斗单位射击对方每一战斗单位的机会大致相同。将双方在战斗中尚存的战斗单位数作为连续的状态变量，以m(t)、n(t)表示在战斗开始后t时刻蓝方、红方在战斗中尚存的作战单位数，可用下列微分方程组来描述战斗过程中双方兵力随时间的损耗关系：
\begin{equation}
\frac{dm(t)}{dn(t)} = \frac{-\beta{n(t)}}{-\alpha{n(t)}}
\end{equation}
式中α、β分别为蓝方、红方在单位时间内每一战斗单位毁伤对方战斗单位的数目， 简称为蓝方、 红方的毁伤率系数。<br />
这是一个连续的方程，它的通解形式、它的实际意义，例如平方率、线性率什么的在网上均有大量论述，这里不再陈述。</p>

<h2 id="红警的伤害机制">红警的伤害机制</h2>
<p>《红色警戒》是一款经典的RTS游戏。我们可以研究红警中的伤害机制，并编写交战模拟平台的程序，从而验证兰彻斯特方程，为交战提供策略。红警作战主要以坦克战为主，因此我们这里的研究对象也就是坦克了。<br />
红警里面有一个Rulesmd.ini文件，用来定义单位的各种属性。红警中坦克分为轻甲、中甲和重甲。武器对对方的伤害是<strong><em>杀伤力乘上对这种装甲的伤害系数</em></strong>。坦克在受到攻击后，血条便减少相应的伤害值。此外，我们在模拟平台中还要体现装弹间隔时间。红警里面部分单位还有自动回血能力，例如天启坦克、基洛夫空艇、武装采矿车等。这里以对战中的头号杀器：犀牛坦克为例，列举这些属性的值：</p>
<ul>
  <li>制造成本：900</li>
  <li>杀伤力：90</li>
  <li>对轻甲、中甲、重甲的伤害分别为：75%，100%，100%</li>
  <li>体力：400</li>
  <li>装弹间隔时间：65</li>
  <li>不具有自动回血能力</li>
</ul>

<p>编写如下的代码：</p>
<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TANK</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">life</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">atk</span><span class="p">;</span>  <span class="c1">//攻击力
</span>    <span class="kt">int</span> <span class="n">target</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">time</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">once</span><span class="p">;</span>  <span class="c1">//判断临死一击
</span>    <span class="kt">int</span> <span class="n">cover</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">armor</span><span class="p">;</span>  <span class="c1">//1、 轻甲 2、中甲 3、重甲
</span>    <span class="kt">int</span> <span class="n">ps</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="n">TANK</span> <span class="n">tank</span><span class="p">;</span>
</code></pre></div></div>

<p>剩下的就是编写程序模拟作战过程了。以一个循环的计数器作为时间线，坦克在最初随意地寻找攻击目标，在锁定目标之后便每间隔一次装填时间完成一次对目标的进攻（以及每经过一次回血周期便恢复一定的血量）。在红警中可能会出现许多个坦克攻击同一辆坦克，导致坦克在毁灭的时刻遭受了远远大于其残余血量的伤害，这个在模拟中也要得到体现。因此，临死一击以及临死所受伤害是一个相对不太好处理的地方。程序里把常见的八种坦克的数据收录进去：灰熊坦克、犀牛坦克、天启坦克、幻影坦克、光棱坦克、遥控坦克、坦克杀手，用户不用手动输入坦克的属性。根据蒙特卡洛方法的思想，对作战过程总共进行1500次模拟。</p>

<p>程序运行的截图如下所示：
<img src="http://localhost:4000/assets//blog_images/tank1.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank2.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank3.png" width="450px" height="200px" />
<img src="http://localhost:4000/assets//blog_images/tank4.png" width="450px" height="200px" /><br />
又比如，模拟结果显示，在理想条件下，30辆犀牛坦克（红军）与25辆坦克杀手（蓝军）交战的结果为</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>交换比：  
最高1.25  
最低0.33  
平均0.64  
价值交换比：0.64  
胜率：11.67%  
零伤亡概率：0.00%  
</code></pre></div></div>
<p>在理想条件下，40辆犀牛坦克（红军）与20辆坦克杀手（蓝军）交战的结果为</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>交换比：  
最高20.00  
最低1.82  
平均3.27  
价值交换比：3.27  
胜率：100.00%  
零伤亡概率：0.00%  
</code></pre></div></div>

<h2 id="总结">总结</h2>
<ul>
  <li>可以看出，连续的兰彻斯特方程对于小数目的离散作战不能真实预测。若将5辆灰熊坦克与3辆犀牛坦克，则5辆灰熊坦克仅能勉强战胜3辆犀牛坦克。而经过实际的模拟，5辆灰熊坦克与3辆犀牛坦克交战，灰熊坦克胜率为100%，且平均只损失一辆坦克1.56辆坦克，足可见两种模型的差距</li>
  <li>若双方是相同数目的同等坦克，则双方胜率均会低于50%。如若1辆坦克对抗1辆同型号坦克，同时开火，则双方都不会获胜（双方坦克同时被摧毁）。若双方各两辆坦克对抗，则双方胜率均为26%。双方十辆坦克对抗，任一方胜率为40%.若双方45辆坦克对抗，则任一方胜率为48%.由此可见，坦克的数目越大，可能出现的情况就越多，出现平局的可能性就越小</li>
  <li>许多人认为成群的光棱海无法击破，实际上单一的光棱坦克没有别的坦克配合的话很难与犀牛坦克群的阵型冲击、天启坦克的重火力重护甲、矿车的重护甲高射速抗衡。尽管光棱坦克射程极远，但没有幻影坦克配合，无法直接正面参与坦克战</li>
  <li>一般而言，人们常常喜欢集中优势兵力攻打某个单位，这种战术在特殊情况下是错误的。例如天启坦克群与别的坦克群交战，天启坦克依靠重火力有很大的胜算，但是如果所有天启坦克集中火力攻击一辆坦克，这样反而浪费炮弹</li>
  <li>这里没有考虑兵种配合的问题。如在坦克阵中假如与之配合的步兵（尤其是反坦克步兵），则既能吸引敌方火力向步兵开火，又能给以敌方杀伤</li>
  <li>作为一个资深红警玩家<strong><em>（2017年更新，早就不玩了）</em></strong>，也知道这个模拟平台还是有不完善的地方。在真实的红警坦克战里，如果考虑操作，那么坦克攻击范围、移动速度、炮塔转动角度、是否能够移动攻击都会造成非常大的影响，更不用提什么分兵战术、迂回战术等。而且这里没有考虑到光棱坦克的溅射伤害和幻影坦克的隐蔽性，还有作战单位升级的情况</li>
  <li>事实上，对于真正的坦克战而言，机动性、射程、移动攻击能力、阵型、布坦协同都是十分重要的，而我的程序模拟的是定点攻击，这实际上与火炮别无两样。坦克需要发挥其阵型冲锋、冲锋打散阵型、移动攻击等机动性优势，例如犀牛坦克常常强势冲锋等战术，这是程序无法模拟的。因此，程序仅仅能提供一个基本的战术参考，这替代不了指挥官的战术决策</li>
  <li>2017年更新：现在看自己以前写的代码感觉是真的丑陋，不过这也说明了自己的代码水平还是有一丢丢进步的:grin:</li>
</ul>
]]></content>
      <categories>
        
          <category> Programming </category>
        
      </categories>
      <tags>
        
          <tag> 兰彻斯特方程 </tag>
        
          <tag> 蒙特卡洛方法 </tag>
        
          <tag> C语言 </tag>
        
          <tag> 作战效能模拟 </tag>
        
      </tags>
      <tags></tags>
    </entry>
  
    <entry>
      <title><![CDATA[Download this Theme]]></title>
      <url>/2015/06/24/download-this-theme/</url>
      <content type="html"><![CDATA[<p><strong><em>Fork</em></strong> or <strong><em>download</em></strong> the theme <a href="https://github.com/Jackpon/Jackpon.github.io">here on GitHub</a>.</p>
]]></content>
      <categories>
        
      </categories>
      <tags>
        
      </tags>
      <tags></tags>
    </entry>
  
</search>
