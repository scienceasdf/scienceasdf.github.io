<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.6.2">Jekyll</generator><link href="http://localhost:4000/atom.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2019-11-19T20:07:40+08:00</updated><id>http://localhost:4000/</id><title type="html">scienceasdf</title><subtitle>We will bury them !</subtitle><author><name>scienceasdf</name></author><entry><title type="html">一个简单的面向对象有限元程序的开发</title><link href="http://localhost:4000/programming/2019/01/09/femcode/" rel="alternate" type="text/html" title="一个简单的面向对象有限元程序的开发" /><published>2019-01-09T00:00:00+08:00</published><updated>2019-01-09T00:00:00+08:00</updated><id>http://localhost:4000/programming/2019/01/09/femcode</id><content type="html" xml:base="http://localhost:4000/programming/2019/01/09/femcode/">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: &quot;AMS&quot;  
                },
     		    extensions: [&quot;AMSmath.js&quot;]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            &quot;HTML-CSS&quot;: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
&lt;div style=&quot;display:none&quot;&gt;
			\( \def\
			&lt;#1&gt;{\left
				&lt;#1\right&gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial
					#1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2
					#1}{\mathrm{d} #2^2}} 
                    \newcommand{\half}{\frac{1}{2}}
\newcommand{\pprime}{\prime\prime}
                    \)
                    \(
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}
\)
&lt;/div&gt;
**本程序使用C++编写，GUI界面使用Qt库，线性代数运算使用Eigen库，实现了二维桁架结构、钢架结构的通用有限元程序，能够计算静载荷下的位移，以及固有频率和固有振型。**

---
## 理论基础
### 桁架结构
二维桁架结构的的刚度矩阵为
  
$$
    \begin{equation}
        \bm{k}=\frac{EA}{L}\begin{bmatrix}
            c^2 &amp; sc &amp; -c^2 &amp; -sc \\
            sc &amp; s^2 &amp; -sc &amp; -s^2 \\
            -c^2 &amp; -sc &amp; c^2 &amp; sc \\
            -sc &amp; -s^2 &amp; sc &amp; s^2
        \end{bmatrix}
    \end{equation}
$$
  
质量矩阵为
  
$$
    \begin{equation}
        \bm{m}=\frac{\rho L}{6}\begin{bmatrix}
            2 &amp; 0 &amp; 1 &amp; 0\\
            0 &amp; 2 &amp; 0 &amp; 1\\
            1 &amp; 0 &amp; 2 &amp; 0\\
            0 &amp; 1 &amp; 0 &amp; 2
        \end{bmatrix}
    \end{equation}
$$
  
其中，$\rho$为线密度。坐标变换矩阵为
    
$$
    \begin{equation}
        \bm{T}=\begin{bmatrix}
            c &amp; s &amp; 0 &amp; 0\\
            -s &amp; c &amp; 0 &amp; 0\\
            0 &amp; 0 &amp; c &amp; s\\
            0 &amp; 0 &amp; -s &amp; c
        \end{bmatrix}
    \end{equation}
$$
  
那么在总体坐标系下的质量矩阵，载荷向量，位移向量为
    \begin{equation}
        \bm{\tilde m}=\bm{T}^T\bm{mT}=\bm{m},\quad \bm{\tilde f}=\bm{T}^T\bm{f},\quad \bm{\tilde v}=\bm{T}^T\bm{v}
    \end{equation}

### 弯曲单元
采用三次梁单元，建立梁单元的刚度矩阵为
  
$$
    \begin{equation}
      \bm{k}=\frac{EI}{L^3}\begin{bmatrix}
        12&amp;6l&amp;-12&amp;6l\\
        6l&amp;4l^2&amp;-6l&amp;2l^2\\
        -12&amp;-6l&amp;12&amp;-6l\\
        6l&amp;2l^2&amp;-6l&amp;4l^2
      \end{bmatrix}
    \end{equation}
$$
  
    
单元质量矩阵为
  
$$
      \begin{equation}
        \bm{m}=\frac{\rho al}{420}\begin{bmatrix}
          156&amp;22l&amp;54&amp;-13l\\
          22l&amp;4l^2&amp;14l&amp;-3l^2\\
          54&amp;13l&amp;156&amp;-22l\\
          -13l&amp;-13l^2&amp;-22l&amp;4l^2
        \end{bmatrix}
      \end{equation}
$$ 
  

对于二维平面上的梁，有坐标转换矩阵为
  
  $$
      \begin{equation}
        \bm{T}=\begin{bmatrix}
            -\sin\alpha &amp; \cos\alpha &amp; 0 &amp; 0 &amp; 0 &amp; 0\\
            0 &amp; 0 &amp; 1 &amp; 0 &amp; 0 &amp; 0\\
            0 &amp; 0 &amp; 0 &amp; -\sin\alpha &amp; \cos\alpha &amp; 0\\
            0 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 1
        \end{bmatrix}
    \end{equation}
    $$
  
那么在总体坐标系下的刚度矩阵为
    \begin{equation}
        \bm{\tilde k}=\bm{T}^T\bm{kT}
    \end{equation}
同理有
    \begin{equation}
        \bm{\tilde m}=\bm{T}^T\bm{mT},\quad \bm{\tilde f}=\bm{T}^T\bm{f},\quad \bm{\tilde v}=\bm{T}^T\bm{v}
    \end{equation}

### 约束的处理
如果无约束的有限元方程是下面的形式：
  
$$
      \begin{equation}
      \begin{bmatrix} k_{1,1} &amp; k_{1,2} &amp; k_{1,3} &amp; k_{1,4} &amp; k_{1,5} &amp; k_{1,6}\\ k_{2,1} &amp; k_{2,2} &amp; k_{2,3} &amp; k_{2,4} &amp; k_{2,5} &amp; k_{2,6}\\ k_{3,1} &amp; k_{3,2} &amp; k_{3,3} &amp; k_{3,4} &amp; k_{3,5} &amp; k_{3,6}\\ k_{4,1} &amp; k_{4,2} &amp; k_{4,3} &amp; k_{4,4} &amp; k_{4,5} &amp; k_{4,6}\\ k_{5,1} &amp; k_{5,2} &amp; k_{5,3} &amp; k_{5,4} &amp; k_{5,5} &amp; k_{5,6}\\ k_{6,1} &amp; k_{6,2} &amp; k_{6,3} &amp; k_{6,4} &amp; k_{6,5} &amp; k_{6,6}\\ \end{bmatrix} \begin{bmatrix} u_1\\v_1\\u_2\\v_2\\u_3\\v_3 \end{bmatrix} = \begin{bmatrix} F_{x1}\\F_{y1}\\F_{x2}\\F_{y2}\\F_{x3}\\F_{y3} \end{bmatrix} 
      \end{equation}
$$
  
那么应用约束条件后，有限元方程应该是这样的形式：
  
$$
      \begin{equation}
      \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 &amp; 0 &amp; 0\\ 0 &amp; k_{2,2} &amp; k_{2,3} &amp; 0 &amp; k_{2,5} &amp; k_{2,6}\\ 0 &amp; k_{3,2} &amp; k_{3,3} &amp; 0 &amp; k_{3,5} &amp; k_{3,6}\\ 0 &amp; 0 &amp; 0 &amp; 1 &amp; 0 &amp; 0\\ 0 &amp; k_{5,2} &amp; k_{5,3} &amp; 0 &amp; k_{5,5} &amp; k_{5,6}\\ 0 &amp; k_{6,2} &amp; k_{6,3} &amp; 0 &amp; k_{6,5} &amp; k_{6,6}\\ \end{bmatrix} \begin{bmatrix} u_1\\v_1\\u_2\\v_2\\u_3\\v_3 \end{bmatrix} = \begin{bmatrix} 0\\F_{y1}\\F_{x2}\\0\\F_{x3}\\F_{y3} \end{bmatrix}  
      \end{equation}
$$ 

## 有限元部分代码
```c++
class trussElement;

class node
{
    friend class trussElement;
    friend class trussStructure;
public:
    node(double x1, double y1)
        :m_x(x1), m_y(y1) {}

private:
    double m_x, m_y;
};

struct Constraint
{
    bool UX;
    bool UY;
    int node;
    Constraint(bool X, bool Y, int n){
        UX = X; UY = Y;
        node = n;
    }
};

std::vector&lt;node&gt; globalNodeList;
// Here I should use singleton later

class trussElement
{
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
public:
    trussElement(std::vector&lt;node&gt;&amp; nodeList,
                 int node1, int node2, double EA, double rho);

    int getNumNode1() {return mNumNode1;}
    int getNumNode2() {return mNumNode2;}

//private:
    int mNumNode1;
    int mNumNode2;

    double m_theta;
    double m_x1, m_x2, m_y1, m_y2;
    double m_EA, m_rho;
    double m_l;

    Eigen::Matrix&lt;double, 4, 4&gt; m_K;
    Eigen::Matrix&lt;double, 4, 4&gt; m_mass;
};

trussElement::trussElement(std::vector&lt;node&gt;&amp; nodeList,
                           int node1, int node2, double EA, double rho) :
    m_x1(nodeList[node1].m_x), m_y1(nodeList[node1].m_y),
    m_x2(nodeList[node2].m_x), m_y2(nodeList[node2].m_y),
    mNumNode1(node1), mNumNode2(node2),
    m_EA(EA), m_rho(rho)
{
    m_theta = std::atan2(m_y2 - m_y1, m_x2 - m_x1);
    m_l = sqrt((m_y2 - m_y1) * (m_y2 - m_y1) 
            + (m_x2 - m_x1) * (m_x2 - m_x1));

    double c = cos(m_theta);
    double s = sin(m_theta);

    m_K &lt;&lt; c * c, s * c, -c * c, -s * c,
           s * c, s * s, -s * c, -s * s,
           -c * c, -s * c, c * c, s * c,
           -s * c, -s * s, s * c, s * s;

    m_K *= m_EA / m_l;

    Eigen::Matrix&lt;double, 4, 4&gt; mass0, trans;
    mass0 &lt;&lt; 2., .0, 1., .0,
             .0, 2., .0, 1.,
             1., .0, 2., .0,
             .0, 1., .0, 2.;
    mass0 *= m_rho * m_l / 6.0;

    trans &lt;&lt; c, s, .0, .0,
             -s, c, .0, .0,
             .0, .0, c, s,
             .0, .0, -s, c;

    m_mass = trans.transpose() * mass0 * trans;
}

class trussStructure
{
public:
    EIGEN_MAKE_ALIGNED_OPERATOR_NEW
    void addTrussElement(const trussElement&amp; elem);

    void addConstraint(Constraint con);

    void removeTrussElement(int i);

    void recalcAllMatrices();

    void addLoad(int numNode, double Fx, double Fy);

//private:
    void recalcLoad();
    void recalcStiffness();
    void recalcMass();

    std::vector&lt;trussElement&gt; trussArray;
    std::vector&lt;Constraint&gt; constrainsArray;
    std::map&lt;int, double&gt; xLoadOnNode;
    std::map&lt;int, double&gt; yLoadOnNode;
    std::vector&lt;int&gt; indicesToConstraint;

    // assemble matrices are no constraints applied,
    // while global matrices are applied.
    Eigen::MatrixXd m_assembleStiffness;
    Eigen::MatrixXd m_assembleMass;
    Eigen::MatrixXd m_globalStiffness;
    Eigen::MatrixXd m_globalMass;
    Eigen::MatrixXd m_assembleLoad;
    Eigen::MatrixXd m_globalLoad;


    Eigen::MatrixXd m_displacement;
};

void trussStructure::addTrussElement(const trussElement &amp;elem)
{
    trussArray.push_back(elem);
}

void trussStructure::addConstraint(Constraint con)
{
    constrainsArray.push_back(con);
    if (con.UX){
        indicesToConstraint.push_back(2 * con.node + 0);
    }
    if (con.UY){
        indicesToConstraint.push_back(2 * con.node + 1);
    }
}

void trussStructure::addLoad(int numNode, double Fx, double Fy)
{
    xLoadOnNode[numNode] += Fx;
    yLoadOnNode[numNode] += Fy;
}

void trussStructure::recalcAllMatrices()
{
    std::sort(indicesToConstraint.begin(), indicesToConstraint.end());
    recalcLoad();
    recalcMass();
    recalcStiffness();
}

void trussStructure::recalcStiffness()
{
    int n = globalNodeList.size();
    m_assembleStiffness = Eigen::MatrixXd::Zero(2 * n, 2 * n);
    for(auto elem : trussArray){
        Eigen::MatrixXd mapMatrix = Eigen::MatrixXd::Zero(4, 2 * n);
        int a1 = elem.getNumNode1();
        int a2 = elem.getNumNode2();
        mapMatrix(0, 2 * a1) = 1.0;
        mapMatrix(1, 2 * a1 + 1) = 1.0;
        mapMatrix(2, 2 * a2) = 1.0;
        mapMatrix(3, 2 * a2 + 1) = 1.0;

        m_assembleStiffness += mapMatrix.transpose() *
                elem.m_K * mapMatrix;
    }

    m_globalStiffness = m_assembleStiffness;
    int j = 0;
    for(int index : indicesToConstraint){
        for(int row = 0; row &lt; 2 * n; ++row){
            for(int col = 0; col &lt; 2 * n; ++col){
                if (row == index || col == index){
                    m_globalStiffness(row, col) = 
                        (row == col) ? 1.0 : 0.0;
                }
            }
        }

        //removeRow(m_globalStiffness,index - j);
        //removeColumn(m_globalStiffness, index - j);
        j++;
    }
}

void trussStructure::recalcMass()
{
    int n = globalNodeList.size();
    m_assembleMass = Eigen::MatrixXd::Zero(2 * n, 2 * n);
    for(auto elem : trussArray){
        Eigen::MatrixXd mapMatrix = Eigen::MatrixXd::Zero(4, 2 * n);
        int a1 = elem.getNumNode1();
        int a2 = elem.getNumNode2();
        mapMatrix(0, 2 * a1) = 1.0;
        mapMatrix(1, 2 * a1 + 1) = 1.0;
        mapMatrix(2, 2 * a2) = 1.0;
        mapMatrix(3, 2 * a2 + 1) = 1.0;

        m_assembleMass += mapMatrix.transpose() *
                elem.m_mass * mapMatrix;

        std::cout &lt;&lt; mapMatrix.transpose() *
                     elem.m_mass * mapMatrix &lt;&lt; &quot;\n\n&quot;;
    }
    m_globalMass = m_assembleMass;
    int j = 0;
    for(int index : indicesToConstraint){
        for(int row = 0; row &lt; 2 * n; ++row){
            for(int col = 0; col &lt; 2 * n; ++col){
                if (row == index || col == index){
                    m_globalMass(row, col) = 
                        (row == col) ? 1.0 : 0.0;
                }
            }
        }

        //removeRow(m_globalMass, index - j);
        //removeColumn(m_globalMass, index - j);
        j++;
    }
}

void trussStructure::recalcLoad()
{
    int n = globalNodeList.size();
    m_assembleLoad = Eigen::MatrixXd::Zero(2 * n, 1);
    for(int i = 0; i &lt; n; ++i){
        m_assembleLoad(2 * i) += xLoadOnNode[i];
        m_assembleLoad(2 * i + 1) += yLoadOnNode[i];
    }

    m_globalLoad = m_assembleLoad;
    int j = 0;
    for(int index : indicesToConstraint){
        for(int row = 0; row &lt; 2 * n; ++row){
                if (row == index){
                    m_globalLoad(row, 0) = 0.0;
                }
        }

        //removeRow(m_globalLoad, index - j);
        j++;
    }
}
```
这里留出比较方便的接口，例如建立一个结构的代码如下:
```c++
double l = .01;
double r = .005;
double a = 3.141592693975358 * r * r;
double e = 7e3 * 1e7;
double EA = e * a;
auto rho = 2778.62;

trussStructure structure1;
globalNodeList.push_back(node(0, 0));
globalNodeList.push_back(node(.5 * l, .5 * sqrt(3.0) * l));
globalNodeList.push_back(node(l, 0));

structure1.addTrussElement(trussElement(globalNodeList,
                                        0, 1, EA, rho));

structure1.addTrussElement(trussElement(globalNodeList,
                                        0, 2, EA, rho));

structure1.addTrussElement(trussElement(globalNodeList,
                                            1, 2, EA, rho));

structure1.addLoad(1, .0, 1e-3);
structure1.addConstraint(Constraint(1, 1, 0));
structure1.addConstraint(Constraint(0, 1, 2));


structure1.recalcAllMatrices();
```
就可以方便地建立一个桁架结构。不过还是需要进一步改善接口，增强其可扩展性。</content><author><name>scienceasdf</name></author><category term="数值算法" /><category term="有限元" /><category term="C++" /><summary type="html">\( \def\ &amp;lt;#1&amp;gt;{\left &amp;lt;#1\right&amp;gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial #1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2 #1}{\mathrm{d} #2^2}} \newcommand{\half}{\frac{1}{2}} \newcommand{\pprime}{\prime\prime} \) \( \newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}} \) 本程序使用C++编写，GUI界面使用Qt库，线性代数运算使用Eigen库，实现了二维桁架结构、钢架结构的通用有限元程序，能够计算静载荷下的位移，以及固有频率和固有振型。</summary></entry><entry><title type="html">一道结构动力学问题的多种方法求解</title><link href="http://localhost:4000/dynamics/2019/01/08/beamdyn/" rel="alternate" type="text/html" title="一道结构动力学问题的多种方法求解" /><published>2019-01-08T00:00:00+08:00</published><updated>2019-01-08T00:00:00+08:00</updated><id>http://localhost:4000/dynamics/2019/01/08/beamdyn</id><content type="html" xml:base="http://localhost:4000/dynamics/2019/01/08/beamdyn/">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: &quot;AMS&quot;  
                },
     		    extensions: [&quot;AMSmath.js&quot;]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            &quot;HTML-CSS&quot;: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
&lt;div style=&quot;display:none&quot;&gt;
			\( \def\
			&lt;#1&gt;{\left
				&lt;#1\right&gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial
					#1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2
					#1}{\mathrm{d} #2^2}} \)
                    \(
\newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}}
\)
&lt;/div&gt;
**本文对一道悬臂梁的动力学响应问题进行了研究，分别实现了时域方法、时域和频域结合的方法、纯频域方法等多种数值方法，并对不同方法进行了比较。**

---
## 题目描述
&lt;img src=&quot;{{ site.url }}/assets//blog_images/exercise1.jpg&quot; width=&quot;100%&quot;/&gt;
如图所示悬臂梁，长度L=1m,弯曲刚度$EI=10\text{Nm}^2$,线密度$\rho=0.3\text{kg/m}^3$,计算当$T=0.1,0.5,1.0s$时梁在$f(t)$作用下的根部弯矩的时间响应。

## 时域方法
### 有限元方法
建立梁单元的刚度矩阵为
  
$$
\begin{equation}
  \bm{k}=\frac{EI}{L^3}\begin{bmatrix}
    12&amp;6l&amp;-12&amp;6l\\
    6l&amp;4l^2&amp;-6l&amp;2l^2\\
    -12&amp;-6l&amp;12&amp;-6l\\
    6l&amp;2l^2&amp;-6l&amp;4l^2
  \end{bmatrix}
\end{equation}
$$

  单元质量矩阵为
    
  $$
  \begin{equation}
    \bm{m}=\frac{\rho al}{420}\begin{bmatrix}
      156&amp;22l&amp;54&amp;-13l\\
      22l&amp;4l^2&amp;14l&amp;-3l^2\\
      54&amp;13l&amp;156&amp;-22l\\
      -13l&amp;-13l^2&amp;-22l&amp;4l^2
    \end{bmatrix}
  \end{equation}
  $$

  将梁分为数个梁单元，边界条件为一端固支。组装有限元方程后，可以通过求$\lambda{\bm{M}^{-1}\bm{K}}$与梁的解析解的固有角频率的平方比较，当划分的网格增大时，特征值趋于梁的解析解的固有角频率的平方，验证有限元模型的正确性。因此写出有限元的动力学方程：
  \begin{equation}
    \bm{M}\bm{\ddot x}+\bm{Kx}=\bm{f}
  \end{equation}

有限元模型计算此模型的固有频率与解析解求得的固有频率对比如表1所示。
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/fem_freq.png&quot; width=&quot;100%&quot;/&gt;

### 龙格库塔算法
  这里采用经典四阶龙格库塔算法。但是由于这里的方程是刚性方程【1】，因此需要将时间步长取到很小才能保证算法的稳定性。在这里得到的结果如图1,图2,图3所示。
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/rk4fig1.png&quot; width=&quot;100%&quot;/&gt;
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/rk4fig2.png&quot; width=&quot;100%&quot;/&gt;
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/rk4fig3.png&quot; width=&quot;100%&quot;/&gt;
    

### 韦尔莱积分算法

  此系统由于没有黏性项，因此我想到了位置韦尔莱积分会比较方便【2】。即使有速度项也可以用速度韦尔莱积分。

  位置韦尔莱的公式以及推导为
    
  $$
    {\displaystyle r(t+\Delta t)=r(t)+v(t)\Delta t+{\frac {f(t)}{2m}}\Delta t^{2}+{\frac {1}{3!}}{\frac {d^{3}r}{dt^{3}}}\Delta t^{3}+O(\Delta t^{4})}    
  $$
    
   $$
    {\displaystyle r(t-\Delta t)=r(t)-v(t)\Delta t+{\frac {f(t)}{2m}}\Delta t^{2}-{\frac {1}{3!}}{\frac {d^{3}r}{dt^{3}}}\Delta t^{3}+O(\Delta t^{4})}    
  $$
    
\begin{equation}
    \Rightarrow {\displaystyle r(t+\Delta t)\simeq 2r(t)-r(t-\Delta t)+{\frac {f(t)}{m}}\Delta t^{2}}
\end{equation}
新位置的计算误差为四阶。我本以为这样可以让算法能够稳定的，但是发现还是不能取过大的步长。得到的结果由于和龙格库塔得到的结果相同，故略去。

### 隐式龙格库塔方法
隐式龙格库塔方法可以具有更好的数值稳定性，更适合用于刚性方程的求解。方程如下：
  
$$
\begin{equation}
    \begin{array}{l}
    y_{n+1}-y_n=\frac{h}{2}(K_1+K_2)\\
    K_1=f(t_n+(\frac{1}{2}+\frac{\sqrt{3}}{6})h,y_n+\frac{1}{4}hK_1+(\frac{1}{4}+\frac{\sqrt{3}}{6})hK_2)\\
    K_2=f(t_n+(\frac{1}{2}-\frac{\sqrt{3}}{6})h,y_n+(\frac{1}{4}-\frac{\sqrt{3}}{6})hK_1+\frac{1}{4}hK_2)
    \end{array}
\end{equation}
$$
  
上式中的隐式方程可以用不动点迭代求解。隐式龙格库塔方法可以在更大的时间步长下保证稳定性。得到的结果如图4,图5,图6所示。
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/yinshi_fig1.png&quot; width=&quot;100%&quot;/&gt;
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/yinshi_fig2.png&quot; width=&quot;100%&quot;/&gt;
  &lt;img src=&quot;{{ site.url }}/assets//blog_images/yinshi_fig3.png&quot; width=&quot;100%&quot;/&gt;

实际上针对刚性方程还有更为有效的算法：Rosenbrock算法【3】，但是由于考前时间有限，没办法去实现了。

### Newmark-β方法
根据【4】,一种常用的Newmark方法可以保证无条件稳定:
  
$$
\begin{equation}
    \left\{\begin{array}{l}
        \dot x_{k+1}=\dot x_k+h[\frac{1}{2}(\ddot x_k + \ddot x_{k+1})]\\
        x_{k+1}=x_k+h\dot x_k+\frac{h^2}{2}[\frac{1}{2}(\ddot x_k+\ddot x_{k+1})]
    \end{array}\right.
\end{equation}
$$
  
Newmark方法除了需要初始位移和初始速度以外，还需要初始加速度。且Newmark方法得到的相位误差滞后。得到的结果和前面的结果几乎相同，因此不再重新作图。

## 时域和频域混合的方法
### 梁的模态分解及传递函数

梁的受迫振动方程为
\begin{equation}\label{beamMotion}
    EI\frac{\partial^4u}{\partial x^4}+\rho\pyypxx{u}{x}=f_0\sin\omega t\delta(x-l)
\end{equation}
通过分离变量可以得到梁的自由振动下的固有振型和固有频率，分别为$\phi_i,\omega_i$,其中
\begin{equation}
    \phi_i(x)=\cosh(\alpha_i x)-\cos(\alpha_i x)+\beta_i[\sinh(\alpha_i x)-\sin(\alpha_i x)]
\end{equation}
且满足
  
$$
\begin{equation}
    \left.\begin{array}{l}
        \omega_i=\alpha_i^2\sqrt{\frac{EI}{\rho}}\\
        \int_0^l\phi_i^2dx=l\\
        \phi_i(l)=2(-1)^{i+1}
    \end{array}\right\}
\end{equation}
$$
  
当梁的自由端作用外力时，按模态进行分解，梁的响应可以设为
\begin{equation}\label{eq1}
    u(t)=\sin\omega t\sum c_i\phi_i(x)
\end{equation}
求出不同模态对这个激励的响应，将式(\ref{eq1})代入至式(\ref{beamMotion})中，乘上某个特定的模态，利用正交性，对式子从$0$到$l$积分，并且
\begin{equation}
    \int_{a^-}^{a^+}p(x)\delta(x-a)dx=p(a)   
\end{equation}
可以得到
\begin{equation}
    c_i=\frac{1}{\rho l}\frac{f_0}{\omega_i^2-\omega^2}
\end{equation} 

### 分解模态后用龙格库塔算法

可以利用模态分解后得到的式子列出二阶运动的微分方程，并用龙格库塔算法求解。当$T=0.1s$时，取前两阶模态计算，当$T=0.5s/1s$时，只取系统的基频计算。得到的梁根部弯矩的响应曲线分别如图7,图8,图9所示。对模态分解之后得到的二阶微分方程仍然是刚性方程，为了求解的数值稳定性，龙格库塔方法的计算步长依然需要很小。因此此种方法相对于纯时域方法只是减少了有限元方法的运算量，龙格库塔算法仍需要大量运算。

&lt;img src=&quot;{{ site.url }}/assets//blog_images/decomp1.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/decomp2.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/decomp3.png&quot; width=&quot;100%&quot;/&gt;

### 分解模态后用杜哈梅尔积分

由条件可知，系统的模态为一个无阻尼二阶系统，可以得到系统的单位脉冲响应为
    \begin{equation}
        c(t)=\frac{1}{\rho l\omega_i}\sin(\omega_i t)
    \end{equation}
    将任意载荷$f(t)$视为一系列脉冲激励的迭加： 
    \begin{equation}
    f(t)\approx \sum {f(\tau )\cdot \Delta \tau \cdot \delta }(t-\tau )
    \end{equation}
    那么根据线性性质可知，系统的响应同样可以表示成对这一系列脉冲激励的响应函数的迭加： 
    \begin{equation}\label{eq:dis}
        x(t)\approx \sum {f(\tau )\cdot \Delta \tau \cdot c}(t-\tau )
    \end{equation}
    根据此编写程序，取前九阶模态，可以得到的响应曲线分别如图10,图11,图12所示。这种方法的运算量相对小很多，而且准确性很高，但是仍然注意到进行离散卷积时采用的取样点的周期如果大于最高阶模态的周期的话会导致很大的误差，因此需要要么少取一些高阶模态，要么减小采样周期。

&lt;img src=&quot;{{ site.url }}/assets//blog_images/duha1.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/duha2.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/duha3.png&quot; width=&quot;100%&quot;/&gt;

## 纯时域方法

对于题目中给的输入信号，我们可以想通过FFT把他分解成三角函数的和的形式，再分别利用FRF对响应的幅值和相位进行计算，再利用IFFT还原为响应。这种方法的理论基础是卷积定理【5】：
\begin{equation}
    \mathcal{F}(f*g) = \mathcal{F}(f) \cdot \mathcal{F}(g)
\end{equation}
可以想象成杜哈梅尔积分的时域形式，单位冲击响应的频域表达式就是FRF.取前七阶模态，这种方法得到的结果分别如图13,图14,图15所示。这种方法的速度很快，这里我自己写的递归FFT并非最快的，如果使用蝶形分治算法还能提升FFT的计算效率。但是这种方法的精度貌似不高，而且和采样周期以及采样时间有很大关系。

&lt;img src=&quot;{{ site.url }}/assets//blog_images/timedomain1.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/timedomain2.png&quot; width=&quot;100%&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/timedomain3.png&quot; width=&quot;100%&quot;/&gt;


## 参考文献
【1】Ernst Hairer and Gerhard Wanner. Solving Ordinary Differential Equations II. Stiff and
Differential-Algebraic Problems. Springer, Berlin, 1996. ID: unige:12344.
  
【2】Jason Gregory. Game engine architecture. Taylor &amp; Francis Ltd., 1 edition, 2009.

【3】William H. Press, Saul A. Teukolsky, William T. Vetterling, and Brian P. Flannery. Numerical
Recipes 3rd Edition: The Art of Scientific Computing. Cambridge University Press,
New York, NY, USA, 3 edition, 2007.

【4】邢誉峰，李敏. 计算固体力学原理与方法. 北京航空航天大学出版社, 2011.

【5】Albert Boggess and Francis J Narcowich. A First Course in Wavelets with Fourier Analysis.
Publishing House of Electronics Industry, 2002.</content><author><name>scienceasdf</name></author><category term="数值算法" /><category term="有限元" /><category term="动力学" /><summary type="html">\( \def\ &amp;lt;#1&amp;gt;{\left &amp;lt;#1\right&amp;gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial #1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2 #1}{\mathrm{d} #2^2}} \) \( \newcommand{\bm}[1]{\boldsymbol{\mathbf{#1}}} \) 本文对一道悬臂梁的动力学响应问题进行了研究，分别实现了时域方法、时域和频域结合的方法、纯频域方法等多种数值方法，并对不同方法进行了比较。</summary></entry><entry><title type="html">哈密顿系统及保辛数值算法</title><link href="http://localhost:4000/dynamics/2018/11/18/hamiltonian/" rel="alternate" type="text/html" title="哈密顿系统及保辛数值算法" /><published>2018-11-18T00:00:00+08:00</published><updated>2018-11-18T00:00:00+08:00</updated><id>http://localhost:4000/dynamics/2018/11/18/hamiltonian</id><content type="html" xml:base="http://localhost:4000/dynamics/2018/11/18/hamiltonian/">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: &quot;AMS&quot;  
                },
     		    extensions: [&quot;AMSmath.js&quot;]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            &quot;HTML-CSS&quot;: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
&lt;div style=&quot;display:none&quot;&gt;
			\( \def\
			&lt;#1&gt;{\left
				&lt;#1\right&gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial
					#1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2
					#1}{\mathrm{d} #2^2}} \)
&lt;/div&gt;
**It is natural to look forward to those discrete systems which preserve
as much as possible the intrinsic properties of the continuous
system. (Feng Kang 1985)**

---
## 哈密顿系统与刘维尔定理
哈密顿系统通常可以写成这样的形式：
  
$$
\begin{array}{l}
\dot p=-\pypx{H}{q}\\
\dot q=\pypx{H}{p}
\end{array}
$$
  
其中$p$为广义动量，$q$为广义坐标（这里为了简化没有写成向量的黑体）。
  
假设哈密顿系统是可分离的，也就是说，哈密顿函数可以写成下面的形式
\begin{equation}
H(p,q)=T(p)+V(q)
\end{equation}
这个是可以在大部分的哈密顿系统中满足，其中$T$就是动能，而$V$就是势能。
  
刘维尔定理：哈密顿系统的相流保持相体积不变。要证明刘维尔定理，只需要证明常微分方程组的散度为0，而这个是易证的。具体证明过程可以参考阿诺尔德的教材《经典力学的数学方法》，这里就不给出详细的证明过程了。那么我们还可以得到结论：哈密顿方程组在相空间中不可能有渐进稳定的点和渐进稳定的极限环。由刘维尔定理还可以推出庞加莱回归定理，具体表述也可以参考阿诺尔德的教材。

## 数值积分算法
[我之前的讨论]({{ site.url }}/programming/2017/03/27/rigidBody/)讨论了许多常用的积分算法，但是这些算法对于哈密顿系统而言有一个缺点：并不保辛。可以用一个直观的图片来反应这个现象：
&lt;img src=&quot;{{ site.url }}/assets//blog_images/hamiltonian.png&quot; width=&quot;100%&quot;/&gt;
像这样的一个哈密顿系统，起初在相流当中有一个图形，根据刘维尔定理经过变换后的图形的面积应该和原图形相等，然而欧拉算法、龙格库塔算法却没有出现这样的现象，因此我们需要保辛的算法。
  
### 分块龙格库塔算法
对于哈密顿方程，可以使用分块的龙格库塔算法：
\begin{equation}
P_i=p_0+h\sum_j a_{ij}k_j\quad Q_i=q_0h\sum_j \hat a_{ij}l_j
\end{equation}
\begin{equation}
p_1=p_0+h\sum_i b_ik_i\quad q_1=q_0+h\sum_i \hat b_il_i
\end{equation}
\begin{equation}
k_i=-\pypx{H}{Q}{P_i,Q_i}\quad l_i=\pypx{H}{p}(P_i,Q_i)
\end{equation}
对于分块龙格库塔算法，有如下定理：如果上式中的系数满足:
\begin{equation}
b_i=\hat{b_i}
\end{equation}
\begin{equation}\label{cond1}
b_i\hat a_{ij}+\hat b_j a_{ji}-b_i\hat b_j=0
\end{equation}
那么算法是保辛的。进一步，若哈密顿系统是可分离的，那么如果系数满足式(\ref{cond1})就说明算法是保辛的。因此，我们可以将系数用如下方式简化：
  
$$\begin{array}{l}
a_{ij}=0\quad i&lt;j\\
\hat a_{ij}=0\quad i\leq j
\end{array}
$$
  
并令
  
$$a_{ij}=b_j(i\geq j)\quad \hat a_{ij}=\hat b_{j}(i&gt;j)$$
  
则可以满足式(\ref{cond1})，直观的可以写成表格：
&lt;img src=&quot;{{ site.url }}/assets//blog_images/symp_coeff.png&quot; width=&quot;100%&quot;/&gt;
算法形式:
&lt;img src=&quot;{{ site.url }}/assets//blog_images/symp_algo.png&quot; width=&quot;100%&quot;/&gt;

特殊情况是当$s=1$时，有分块欧拉方法
\begin{equation}
p_1=p_0-h\pypx{U}{q}(q_0)\quad q_1=q_0+h\pypx{T}{p}(p_1)
\end{equation}
交换$p,q$还可以得到
\begin{equation}
q_1=q_0+h\pypx{T}{p}(p_0)\quad p_1=p_0-h\pypx{U}{q}(q_1)
\end{equation}
上面两种算法是保辛且互为伴随的。
  
三阶的系数可以取
  
$$\begin{array}{cccc}
b:&amp;\frac{7}{24}&amp;\frac{3}{4}&amp;\frac{-1}{24}\\
\hat b:&amp;\frac{2}{3}&amp;\frac{-2}{3}&amp;1
\end{array}
$$
  
四阶的系数可以取
  
$$\begin{array}{ccccc}
b:&amp;\frac{1}{2(2-2^{1/3})}&amp;\frac{1-2^{1/3}}{2(2-2^{1/3})}&amp;\frac{1-2^{1/3}}{2(2-2^{1/3})}&amp;\frac{1}{2(2-2^{1/3})}\\
\hat b:&amp;\frac{1}{2-2^{1/3}}&amp;\frac{-2^{1/3}}{2-2^{1/3}}&amp;\frac{1}{2-2^{1/3}}&amp;0
\end{array}
$$

## 参考文献
【1】[Symplectic integrator - Wikipedia](https://en.wikipedia.org/wiki/Symplectic_integrator)感觉好像有地方有错
  
【2】Ernst Hairer, Syvert P. Nørsett, and Gerhard Wanner, Solving Ordinary Differential Equations I: Nonstiff Problems, 2nd ed. (Springer, Berlin, 2009). 

【3】B.И.阿诺尔德, 阿诺尔德, 齐民友. 经典力学的数学方法[M]. 高等教育出版社, 2006.

【4】Haruo Yoshida, “Construction of higher order symplectic integrators,” Physics Letters A 150, no. 5 (November 12, 1990): 262-268. 

【5】Forest, E.; Ruth, Ronald D. (1990). &quot;Fourth-order symplectic integration&quot;. Physica D. 43: 105.</content><author><name>scienceasdf</name></author><category term="数值算法" /><category term="刚体动力学" /><summary type="html">\( \def\ &amp;lt;#1&amp;gt;{\left &amp;lt;#1\right&amp;gt;} \newcommand{\CC}{\bm{C}} \newcommand{\dydx}[2]{\frac{\mathrm{d}#1}{\mathrm{d}#2}} \newcommand{\pypx}[2]{\frac{\partial #1}{\partial #2}} \newcommand{\pyypxx}[2]{\frac{\partial^2 #1}{\partial #2^2}} \newcommand{\dyydxx}[2]{\frac{\mathrm{d}^2 #1}{\mathrm{d} #2^2}} \) It is natural to look forward to those discrete systems which preserve as much as possible the intrinsic properties of the continuous system. (Feng Kang 1985)</summary></entry><entry><title type="html">用LaTeX画足球场与阵型</title><link href="http://localhost:4000/latex/2018/09/21/latex_football/" rel="alternate" type="text/html" title="用LaTeX画足球场与阵型" /><published>2018-09-21T00:00:00+08:00</published><updated>2018-09-21T00:00:00+08:00</updated><id>http://localhost:4000/latex/2018/09/21/latex_football</id><content type="html" xml:base="http://localhost:4000/latex/2018/09/21/latex_football/">**This post is showing how to draw a football field in LaTeX. The contents are all unoriginal.本文展示如何用LaTeX画足球场。（非原创）**

---
谷歌到的关于这个的结果很少，但还是得到了答案。没有专门的宏包来绘制这个东西，不过可以用tikz宏包。

## 鸭子形状的球员
&lt;img src=&quot;{{ site.url }}/assets//blog_images/duck_soccer1.png&quot; width=&quot;600px&quot; height=&quot;400px&quot;/&gt;
```latex
\documentclass[tikz,border=2mm]{standalone} 
\usetikzlibrary{positioning, ducks}
\usepackage{tikzducks}

\newcommand{\croacia}[3]{
\begin{scope}[shift={#3}, xscale=-.4, yscale=.4]
\duck
\path[preaction={fill=red}, pattern=checkerboard, pattern color=white] \duckpathjacket;
\node[font=\sffamily\bfseries] at ([xshift=5mm]wing) {#1};
\node[font=\sffamily\bfseries] at (1.1,-.22) {#2};
\end{scope}
}

\newcommand{\france}[3]{
\begin{scope}[shift={#3}, scale=.4]
\duck[jacket=blue]
\node[font=\sffamily\bfseries] at ([xshift=5mm]wing) {#1};
\node[font=\sffamily\bfseries] at (1.1,-.22) {#2};
\end{scope}
}

\definecolor{field}{RGB}{0,156,0}

\newcommand\area[2]{
\begin{scope}[shift={(#1)}, transform shape, rotate=#2]
\node[minimum width=.55cm,minimum height=1.832cm, anchor=west] (small#2) at (0,0) {};
\node[minimum width=1.65cm,minimum height=4.032cm, anchor=west] (big#2) at (0,0) {};
\node[minimum width=.244cm, minimum height=.732cm, anchor=east] (goal#2) at (0,0) {};
\node[inner sep=.3mm, circle, fill=white] (penalty#2) at (1.1,0) {};
    \begin{scope}
    \tikzset{every path/.style={}}
    \clip (big#2.south east) rectangle ++ (1,5); 
    \draw[white, very thick] (penalty#2) circle (0.915cm);
    \end{scope}
\end{scope}
}


\begin{document}
\begin{tikzpicture}
\begin{scope}[%    
    every node/.style={draw=white, very thick, inner sep=0, outer sep=0},
   every path/.style={draw=white, very thick},
]
\fill[field] (-1,-1) rectangle (13,10);
\node[minimum width=12cm, minimum height=9cm] (contour) at (6,4.5) {};

%\draw (contour.south west) grid (contour.north east);

% Center
\draw (contour.north) -- (contour.south);
\draw (contour.center) circle (0.915cm);
\fill[white] (contour.center) circle (.5mm);

% Areas
\area{contour.west}{0}
\area{contour.east}{180}

% Corners
\foreach \corner [count=\xi starting from 0] in {south west, south east, north east, north west}{
    \begin{scope}[rotate around={90*\xi:(contour.\corner)}]
        \draw ([xshift=1mm]contour.\corner) arc (0:90:1mm);
    \end{scope}
}
\end{scope}

\croacia{23}{Subasic}{(1.25,4.25)}
\croacia{3}{Strinic}{(2.6,7.2)}
\croacia{21}{Vida}{(2.3,5.3)}
\croacia{6}{Lovren}{(2.3,2.9)}
\croacia{2}{Virsalijko}{(2.6,1)}
\croacia{11}{Brozovic}{(3.5,4.25)}
\croacia{4}{Perisic}{(4.5,7.2)}
\croacia{7}{Rakitic}{(4.5,5.25)}
\croacia{10}{Modric}{(4.5,3)}
\croacia{18}{Rebic}{(4.5,1)}
\croacia{17}{Mandzukic}{(5.6,4.25)}

\france{1}{Lloris}{(10.75,4.25)}
\france{2}{Pavard}{(9.5,7.2)}
\france{4}{Varane}{(9.5,5.3)}
\france{5}{Umtiti}{(9.5,2.9)}
\france{21}{Lucas}{(9.5,1)}
\france{13}{Kante}{(8.5,6)}
\france{6}{Pogba}{(8.5,2.3)}
\france{10}{Mbappe}{(7,7)}
\france{7}{Griezman}{(7.8,4.25)}
\france{14}{Matuidi}{(7,1.5)}
\france{9}{Giroud}{(6.4,4.25)}
\end{tikzpicture}
\end{document}
```

## 正常外形的球员
用的是`tikzpeople`.这个不太容易给克罗地亚的队服加上格子花纹了。
&lt;img src=&quot;{{ site.url }}/assets//blog_images/soccer2.png&quot; width=&quot;600px&quot; height=&quot;400px&quot;/&gt;
```latex
\documentclass[tikz,border=2mm]{standalone} 
\usetikzlibrary{positioning}
\usepackage{tikzmarmots}

\newcommand{\croacia}[3]{ \begin{scope}[shift={#3}, scale=.5] \marmot \path[preaction={fill=red}, pattern=checkerboard, pattern color=white] (1.35,0.71) .. controls (1.35,0.41) and (1.17,0.37) .. (0.92,0.37) .. controls (0.69,0.37) and (0.48,0.41) .. (0.48,0.71) .. controls (0.48,1.01) and (0.67,1.26) .. (0.91,1.26) .. controls (1.15,1.26) and (1.3 5,1.01) .. (1.35,0.71) -- cycle; \node[font=\sffamily\bfseries] at (0.95,0.82) {#1}; \node[font=\sffamily\bfseries] at (1.1,-.22) {#2}; \end{scope} }

\newcommand{\france}[3]{ \begin{scope}[shift={#3}, scale=.5] \marmot[body=brown!80!yellow] \path[fill=blue] (1.35,0.71) .. controls (1.35,0.41) and (1.17,0.37) .. (0.92,0.37) .. controls (0.69,0.37) and (0.48,0.41) .. (0.48,0.71) .. controls (0.48,1.01) and (0.67,1.26) .. (0.91,1.26) .. controls (1.15,1.26) and (1.3 5,1.01) .. (1.35,0.71) -- cycle; \node[font=\sffamily\bfseries] at (0.95,0.82) {#1}; \node[font=\sffamily\bfseries] at (1.1,-.22) {#2}; \end{scope} }
\definecolor{field}{RGB}{0,156,0}

\newcommand\area[2]{
\begin{scope}[shift={(#1)}, transform shape, rotate=#2]
\node[minimum width=.55cm,minimum height=1.832cm, anchor=west] (small#2) at (0,0) {};
\node[minimum width=1.65cm,minimum height=4.032cm, anchor=west] (big#2) at (0,0) {};
\node[minimum width=.244cm, minimum height=.732cm, anchor=east] (goal#2) at (0,0) {};
\node[inner sep=.3mm, circle, fill=white] (penalty#2) at (1.1,0) {};
    \begin{scope}
    \tikzset{every path/.style={}}
    \clip (big#2.south east) rectangle ++ (1,5); 
    \draw[white, very thick] (penalty#2) circle (0.915cm);
    \end{scope}
\end{scope}
}


\begin{document}
\begin{tikzpicture}
\begin{scope}[%    
    every node/.style={draw=white, very thick, inner sep=0, outer sep=0},
   every path/.style={draw=white, very thick},
]
\fill[field] (-1,-1) rectangle (13,10);
\node[minimum width=12cm, minimum height=9cm] (contour) at (6,4.5) {};

%\draw (contour.south west) grid (contour.north east);

% Center
\draw (contour.north) -- (contour.south);
\draw (contour.center) circle (0.915cm);
\fill[white] (contour.center) circle (.5mm);

% Areas
\area{contour.west}{0}
\area{contour.east}{180}

% Corners
\foreach \corner [count=\xi starting from 0] in {south west, south east, north east, north west}{
    \begin{scope}[rotate around={90*\xi:(contour.\corner)}]
        \draw ([xshift=1mm]contour.\corner) arc (0:90:1mm);
    \end{scope}
}
\end{scope}

\croacia{23}{Subasic}{(0.25,4.25)}
\croacia{3}{Strinic}{(1.6,7.2)}
\croacia{21}{Vida}{(1.3,5.3)}
\croacia{6}{Lovren}{(1.3,2.9)}
\croacia{2}{Virsalijko}{(1.6,1)}
\croacia{11}{Brozovic}{(2.5,4.25)}
\croacia{4}{Perisic}{(3.5,7.2)}
\croacia{7}{Rakitic}{(3.5,5.25)}
\croacia{10}{Modric}{(3.5,3)}
\croacia{18}{Rebic}{(3.5,1)}
\croacia{17}{Mandzukic}{(4.6,4.25)}

\france{1}{Lloris}{(10.75,4.25)}
\france{2}{Pavard}{(9.5,7.2)}
\france{4}{Varane}{(9.5,5.3)}
\france{5}{Umtiti}{(9.5,2.9)}
\france{21}{Lucas}{(9.5,1)}
\france{13}{Kante}{(8.5,6)}
\france{6}{Pogba}{(8.5,2.3)}
\france{10}{Mbappe}{(7,7)}
\france{7}{Griezman}{(7.8,4.25)}
\france{14}{Matuidi}{(7,1.5)}
\france{9}{Giroud}{(6.4,4.25)}
\end{tikzpicture}
\end{document}
```

## 七人制的一个阵型
&lt;img src=&quot;{{ site.url }}/assets//blog_images/soccer3.png&quot; width=&quot;600px&quot; height=&quot;400px&quot;/&gt;
只需要改一下一些坐标就行了。

## 绘制球场
&lt;img src=&quot;{{ site.url }}/assets//blog_images/soccer4.png&quot; width=&quot;600px&quot; height=&quot;400px&quot;/&gt;
```latex
\documentclass[margin=10pt]{standalone}
\usepackage{tikz}
\usetikzlibrary{arrows.meta, calc}

\definecolor{field}{RGB}{0,156,0}

\tikzset{
    every node/.style={draw=white, very thick, inner sep=0, outer sep=0},
    every path/.style={draw=white, very thick},
}

\newcommand\area[2]{
\begin{scope}[shift={(#1)}, transform shape, rotate=#2]
\node[minimum width=.55cm,minimum height=1.832cm, anchor=west] (small#2) at (0,0) {};
\node[minimum width=1.65cm,minimum height=4.032cm, anchor=west] (big#2) at (0,0) {};
\node[minimum width=.244cm, minimum height=.732cm, anchor=east] (goal#2) at (0,0) {};
\node[inner sep=.3mm, circle, fill=white] (penalty#2) at (1.1,0) {};
    \begin{scope}
    \tikzset{every path/.style={}}
    \clip (big#2.south east) rectangle ++ (1,5); 
    \draw[white, very thick] (penalty#2) circle (0.915cm);
    \end{scope}
\end{scope}
}

\newcommand\showmeasures{
    \begin{scope}
    \tikzset{every node/.style={draw=none,fill=field, inner sep=2pt, sloped}}
    \draw[black, {Latex}-{Latex}] ($(contour.north west)+(0,.5)$) -- ($(contour.north east)+(0,.5)$) node[midway] {\textbf{Sideline:} min 90m - max 120m};
    \draw[black, {Latex}-{Latex}] ($(contour.south west)+(-.6,0)$) -- ($(contour.north west)+(-.6,0)$) node[midway] {\textbf{Goal line:} min 45m - max 90m};
    \draw[black, -{Latex}] (penalty0) --++ (-15:0.915cm) node[midway, above, font=\scriptsize, fill=none, yshift=2pt] {r = 9.15m};
    \draw[black, {Latex}-{Latex}] ($(small0.south east)+(-.2,0)$) -- ($(small0.north east)+(-.2,0)$) node[midway,above, fill=none,font=\scriptsize] {18.32m};
    \draw[black] ($(small0.north west)+(0,.2)$) -- ($(small0.north east)+(0,.2)$) node[midway, above, font=\scriptsize, fill=none, xshift=3pt] {5.50m};
    \draw[black] (contour.south east) --++ (135:1mm) node[anchor=south east] {r = 1m};
    \draw[black, {Latex}-{Latex}] ($(big180.south east)+(-.5,0)$) -- ($(big180.north east)+(-.5,0)$) node[midway,above, rotate=180,fill=none,font=\scriptsize] {40.32m};
    \draw[black, {Latex}-{Latex}] ($(big180.south west)+(0,.2)$) -- ($(big180.south east)+(0,.2)$) node[midway,above,fill=none,font=\scriptsize] {16.50m};
    \draw[black] (contour.east) --++ (-11mm,0) node[midway,above, fill=none,font=\scriptsize] {11m};
    \node[font=\small, rotate=-90, yshift=5mm] at (goal180) {\textbf{Goal:} 7.32m $\times$ 2.44m};
    \draw[black, -{Latex}] (contour.center) --++ (0:0.915cm) node[midway, above, fill=none,font=\scriptsize, yshift=2pt] {r = 9.15m};
    \end{scope}
}

\begin{document}
\begin{tikzpicture}
\fill[field] (-1,-1) rectangle (13,10);
\node[minimum width=12cm, minimum height=9cm] (contour) at (6,4.5) {};

% Center
\draw (contour.north) -- (contour.south);
\draw (contour.center) circle (0.915cm);
\fill[white] (contour.center) circle (.5mm);

% Areas
\area{contour.west}{0}
\area{contour.east}{180}

% Corners
\foreach \corner [count=\xi starting from 0] in {south west, south east, north east, north west}{
    \begin{scope}[rotate around={90*\xi:(contour.\corner)}]
        \draw ([xshift=1mm]contour.\corner) arc (0:90:1mm);
    \end{scope}
}

\showmeasures
\end{tikzpicture}
\end{document}
```</content><author><name>scienceasdf</name></author><summary type="html">This post is showing how to draw a football field in LaTeX. The contents are all unoriginal.本文展示如何用LaTeX画足球场。（非原创）</summary></entry><entry><title type="html">一些Qt在Ubuntu下的问题</title><link href="http://localhost:4000/math/2018/09/18/qt_on_ubuntu/" rel="alternate" type="text/html" title="一些Qt在Ubuntu下的问题" /><published>2018-09-18T00:00:00+08:00</published><updated>2018-09-18T00:00:00+08:00</updated><id>http://localhost:4000/math/2018/09/18/qt_on_ubuntu</id><content type="html" xml:base="http://localhost:4000/math/2018/09/18/qt_on_ubuntu/">**In this post we will talk about some problems occured in Ubuntu OS when writing Qt program.本文讨论一些在ubuntu使用Qt的问题。**

---

## qDebug的使用
通常而言，实际上`qDebug`是不能直接输出`std::string`的，但是在Windows和Android上直接拿来用没有遇到过问题。。。在Ubuntu上使用会报错，因此需要重载&lt;&lt;操作符：
```c++
QDebug operator&lt;&lt;(QDebug out, const std::string&amp; str)
{
    out &lt;&lt; QString::fromStdString(str);
    return out;
}
```
  
## ssl的使用
在把paperServer服务器从Win/Android移植到Linux下遇到了问题，如果访问https连接的话，会发现ssl的函数没有实现。具体的，发现自己其实已经安装了openssl,libssl-dev的包，可是还是不对。我们输出一下相关的信息：
```c++
qDebug()&lt;&lt;&quot;SSL version use for build: &quot;&lt;&lt;QSslSocket::sslLibraryBuildVersionString();
qDebug()&lt;&lt;&quot;SSL version use for run-time: &quot;&lt;&lt;QSslSocket::sslLibraryVersionNumber();
qDebug()&lt;&lt;QCoreApplication::libraryPaths();
```
  
发现Qt的ssl是基于1.0版本的，而apt得到的是1.1版本的，二者并不兼容。因此需要安装`sudo apt-get install libssl1.0-dev`，会把原来的ssl库卸载掉，而且还会连带卸载petsc库。。。。。。解决方法是系统中安装openssl1.1，而自己编译一个openssl1.0.2的so，一定要动态编译（`./config shared`)，不然无法链接，因为我Qt是编译的动态库。然后很坑的是设置elf的RUNPATH居然不管用，必须要`export LD_LIBRARY_PATH=$PWD`才能让程序正确地链接到同目录下的ssl。真是天坑。。。</content><author><name>scienceasdf</name></author><category term="数值算法" /><summary type="html">In this post we will talk about some problems occured in Ubuntu OS when writing Qt program.本文讨论一些在ubuntu使用Qt的问题。</summary></entry><entry><title type="html">切比雪夫多项式、节点与插值</title><link href="http://localhost:4000/math/2018/09/15/chebyshev/" rel="alternate" type="text/html" title="切比雪夫多项式、节点与插值" /><published>2018-09-15T00:00:00+08:00</published><updated>2018-09-15T00:00:00+08:00</updated><id>http://localhost:4000/math/2018/09/15/chebyshev</id><content type="html" xml:base="http://localhost:4000/math/2018/09/15/chebyshev/">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: &quot;AMS&quot;  
                },
     		    extensions: [&quot;AMSmath.js&quot;]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            &quot;HTML-CSS&quot;: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
&lt;/script&gt;
&lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
**In this post we discuss on Chebyshev polynomials, nodes and interpolation.讨论关于切比雪夫多项式、节点与插值**

---
## 切比雪夫节点
对于拉格朗日插值公式，如何选取节点是一个重要的问题。通常而言，等距选取节点并不是一个最优的选择。我们考虑如下的问题描述：
取插值节点：$a\leq x_0\leq x_1\leq ......\leq x_n\leq b$
满足$L_n(x_k)=f(x_k)$的多项式插值余项
  
$$R_n(x)=f(x)-L_n(x)=\frac{f^{(n+1)}(\zeta_n)}{(n+1)!}\omega_{n+1}(x)$$
  
其中，
  
$$\omega_{n+1}(x)=(x-x_0)(x-x_1)...(x-x_n)$$
  
选取$x_0,x_1,......,x_n$使
  
$$\text{max}|\omega_{n+1}(x)|=\text{min}$$
  
因此需要选取切比雪夫多项式$T_{n+1}(x)$的全部零点。
  
如果$a=-1,b=1$,那么
  
$$x_k=\cos(\frac{(2k+1)\pi}{2(n+1)})$$
  
如果$[a,b]\neq [-1,1]$,那么
  
$$x_k=\frac{b+a}{2}+\frac{b-a}{2}\cos(\frac{(2k+1)\pi}{2(n+1)})$$
  
当然选取了节点之后既可以用拉格朗日插值，也可以用牛顿插值。
  
## 切比雪夫多项式
在微分方程的研究中，切比雪夫提出切比雪夫微分方程
  
$$(1-x^2)y^{\prime\prime}-xy^\prime+n^2y=0$$
  
和
  
$$(1-x^2)y^{\prime\prime}-3xy^\prime+n(n+2)y=0$$
  
相应地，第一类和第二类切比雪夫多项式分别为这两个方程的解。 这些方程是斯图姆-刘维尔微分方程的特殊情形。本文只研究第一类切比雪夫多项式。
  
第一类切比雪夫多项式由以下递推关系确定 
  
$$T_0(x)=1$$
  
$$T_1(x)=x$$
  
$$T_{n+1}(x)=2xT_n(x)-T_{n-1}(x)$$
  
也可以用母函数表示
$$\sum_{n=0}^\infty T_n(x)t^n=\frac{1-tx}{1-2tx+t^2}$$

切比雪夫多项式也具有正交性，即
  
$$\int_{-1}^1 T_n(x)T_m(x)\frac{dx}{\sqrt{1-x^2}}=\left\{
    \begin{array}{c}
    0：n\neq m\\
    \pi:n=m=0\\
    \pi/2:n=m\neq 0
    \end{array}
    \right.$$

离散形式的正交性可以表示为
  
$$\sum_{k=1}^{n+1} T_i(x_k)T_j(x_k)=\left\{
    \begin{array}{c}
    0：i\neq j\\
    n+1:i=j=0\\
    \frac{1}{2}(n+1):0&lt;i=j\neq n
    \end{array}
    \right.$$
  
根据正交性，可以得到另外一种方法来进行拉格朗日插值。设$$p_n(x)=\sum_{i=0}^nc_iT_i(x)$$
，易得
  
$$c_i=\frac{2}{n+1}\sum_{k=1}^{n+1}f(x_k)T_i(x_k)$$</content><author><name>scienceasdf</name></author><category term="数值算法" /><summary type="html">In this post we discuss on Chebyshev polynomials, nodes and interpolation.讨论关于切比雪夫多项式、节点与插值</summary></entry><entry><title type="html">再谈C++的字符串分割</title><link href="http://localhost:4000/programming/2018/08/25/splitstring/" rel="alternate" type="text/html" title="再谈C++的字符串分割" /><published>2018-08-25T00:00:00+08:00</published><updated>2018-08-25T00:00:00+08:00</updated><id>http://localhost:4000/programming/2018/08/25/splitstring</id><content type="html" xml:base="http://localhost:4000/programming/2018/08/25/splitstring/">**再次讨论如何分割C++的std::string.**

---

一些别的方法我们之前已经讨论过了，例如Boost::tokenizer或者Boost::splitter或者QString来进行分割。不过这里我们讨论一下运用C++标准库的方法。
  
思路很简单，就是用istream流的迭代器处理。
## 思路1
首先一个比较简单的用法是
```c++
std::string text = &quot;Let me split this into words&quot;;

std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;std::string&gt;(iss)),std::istream_iterator&lt;std::string&gt;());
```
如果使用C++11语法可以写成这样：
```c++
std::string text = &quot;Let me split this into words&quot;;

std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;std::string&gt;{iss}),std::istream_iterator&lt;std::string&gt;());
```
这种思路的优点是可以处理任何流而不仅仅是字符串，但是缺点是不能自定义分隔符。

## 思路2
```c++
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, std::string&amp; output)
{
   // ...does lots of things...
}
```
这段代码肯定是不能改的，因为这是标准库里的东西。不过我们可以变通一下：
```c++
class WordDelimitedByComma : public std::string
{};
```
这样做实际上是有争议的，因为std::string没有一个虚的析构函数，因此最好不要从std::string继承。当然，只要不去删除一个指向`WordDelimitedByComma`的指针，就不会出现问题。在这里我们只用来分割字符串。重载&lt;&lt;操作符：
```c++
std::istream&amp; operator&gt;&gt;(std::istream&amp; is, WordDelimitedByComma&amp; output)
{
    std::getline(is, output, ',');
    return is;
}
```
因此代码可以写成
```c++
std::string text = &quot;Let,me,split,this,into,words&quot;;

std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedByComma&gt;(iss)), std::istream_iterator&lt;WordDelimitedByComma&gt;());
```
更为通用的代码可以写成
```c++
template&lt;char delimiter&gt;
class WordDelimitedBy : public std::string
{};

std::string text = &quot;Let,me,split,this,into,words&quot;;

std::istringstream iss(text);
std::vector&lt;std::string&gt; results((std::istream_iterator&lt;WordDelimitedBy&lt;','&gt;&gt;(iss)), std::istream_iterator&lt;WordDelimitedBy&lt;','&gt;&gt;());
```
这个的优点是
* 允许在编译器定义任意的分隔符
* 可以使用任何流而不仅仅是字符串
* 比方法1快20%至30%
  
而缺点是分隔符只能在编译器定义，且代码量较大。

## 思路3
```c++
std::vector&lt;std::string&gt; split(const std::string&amp; s, char delimiter)
{
    std::vector&lt;std::string&gt; tokens;
    std::string token;
    std::istringstream tokenStream(s);
    while(std::getline(tokenStream, token, delimiter)){
        tokens.push_back(token);
    }
    return tokens;
}
```
这个思路的有点在于
* 接口清晰
* 能够在运行期使用任何分隔符</content><author><name>scienceasdf</name></author><category term="C++" /><summary type="html">再次讨论如何分割C++的std::string.</summary></entry><entry><title type="html">初窥Qt WebAssembly</title><link href="http://localhost:4000/programming/2018/08/23/qtwasm/" rel="alternate" type="text/html" title="初窥Qt WebAssembly" /><published>2018-08-23T00:00:00+08:00</published><updated>2018-08-23T00:00:00+08:00</updated><id>http://localhost:4000/programming/2018/08/23/qtwasm</id><content type="html" xml:base="http://localhost:4000/programming/2018/08/23/qtwasm/">**Qt 5.11发布了Qt WebAssembly的技术预览(Technology Preview)。对Qt WebAssembly的代码进行了编译并编译了一些程序。**

---

## 安装最新emscripten
开发机系统为Ubuntu 18.04，直接用apt install 得到的emscripten版本太老，因此需要最新版本的[emscripten](https://s3.amazonaws.com/mozilla-games/emscripten/releases/emsdk-portable.tar.gz).下载解压后
```
./emsdk update
./emsdk install latest
./emsdk activate latest
```
然后设置环境变量，可以`source ./emsdk_env.sh`

## 编译Qt-WebAssembly源码
首先下载好源码，然后坑也不少。按照官方wiki的命令编译不了，需要用命令`./configure -xplatform emscripten -developer-build -release -static -no-thread -nomake tests -nomake examples  -no-dbus -no-headersclean -system-libpng -no-ssl -no-warnings-are-errors`编译。编译的时候会提示不能确定指令集架构，是因为用了emscripten1.38的原因，需要在qtbase文件夹下的configure.pri修改
```
else: html5:exists($$test_out_dir/arch.js.mem): \
content = $$cat($$test_out_dir/arch.js.mem, blob)
```
改成
```
html5:exists($$test_out_dir/arch.wasm): \
content = $$cat($$test_out_dir/arch.wasm, blob)
```
就可以configure然后make了。

## 编译一个具体的程序
编译程序用命令
```
/qtbase/bin/qmake 
make
```
然后可以用命令`python -m SimpleHTTPServer`启动一个简单的http服务器。
  
不过编译的时候也有坑，不知道为什么，include目录不能有/usr/include，具体只能加上自己的目录，例如/usr/include/eigen3.这个问题的原因目前没有明白。

## 实际效果
我把easyAuto给编译成了wasm文件。具体的文件包括有easyAuto.js, easyAuto.wasm, easyAuto.html, qtloader.js, qtlogo.svg.最后的效果见[网站](https://scienceasdf.gitee.io/site/rootLocus/index.html)。在easyAuto中的QtChart不能使用openGL加速绘制。此外还有的坑包括
* iOS设备不支持wasm
* 移动设备打开网页后，文本框无法触发虚拟键盘。这是因为整个Qt程序是一个canvas，其中的文本框不是dom对象，因此文本框只能用外部键盘输入，或者自己画一个键盘。。。。。。。
* Qt程序不能调用系统的字体，程序里面自带了英文字体，而中文字体则无法显示。奇怪的是我在程序里面加上中文字体一起打包编译仍然显示中文不出。好像是需要在源码中改/qtbase/src/plugins/platforms/html5/font里面的qrc，具体是不是我也不知道。。。。。。
* wasm文件很大，不过倒是可以在服务器端压缩。
* 在手机上运行很卡，而且有的demo甚至会闪退。
* 无法获取本地文件，解决方法见[这里](https://codereview.qt-project.org/#/c/228599/)。
  
总的感觉坑还是不少，不过这个只是技术预览，最终版希望能够有很大改进。这里给出几张easyAuto-WebAssembly程序的截图吧。
&lt;img src=&quot;{{ site.url }}/assets//blog_images/easyauto_wasm1.png&quot; width=&quot;350px&quot; height=&quot;200px&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/easyauto_wasm2.png&quot; width=&quot;350px&quot; height=&quot;200px&quot;/&gt;
&lt;img src=&quot;{{ site.url }}/assets//blog_images/easyauto_wasm3.png&quot; width=&quot;350px&quot; height=&quot;200px&quot;/&gt;</content><author><name>scienceasdf</name></author><category term="Ubuntu" /><category term="Linux" /><summary type="html">Qt 5.11发布了Qt WebAssembly的技术预览(Technology Preview)。对Qt WebAssembly的代码进行了编译并编译了一些程序。</summary></entry><entry><title type="html">最近使用Ubuntu的一些总结</title><link href="http://localhost:4000/programming/2018/06/02/ubuntu/" rel="alternate" type="text/html" title="最近使用Ubuntu的一些总结" /><published>2018-06-02T00:00:00+08:00</published><updated>2018-06-02T00:00:00+08:00</updated><id>http://localhost:4000/programming/2018/06/02/ubuntu</id><content type="html" xml:base="http://localhost:4000/programming/2018/06/02/ubuntu/">**最近使用Ubuntu系统的一些小技巧总结。**

---

## 编译最新CMake
```
sudo apt remove cmake
sudo apt purge --auto-remove cmake
version=3.11
build=1
mkdir ~/temp
cd ~/temp
wget https://cmake.org/files/v$version/cmake-$version.$build.tar.gz
tar -xzvf cmake-$version.$build.tar.gz
cd cmake-$version.$build
./bootstrap
make -j16
sudo make install
cmake --version
```

## 创建快捷方式
```
sudo apt-get install --no-install-recommends gnome-panel
gnome-desktop-item-edit --create-new ~/桌面
```

## 从HDMI输出声音
```
sudo apt-add-repository ppa:yktooo/ppa
sudo apt update
sudo apt install indicator-sound-switcher
```
利用indicator-sound-switcher便可以在各个通道切换声音输出。注意Ubuntu 18.04添加ppa以后不需要`sudo apt update`这一步了。</content><author><name>scienceasdf</name></author><category term="Ubuntu" /><category term="Linux" /><summary type="html">最近使用Ubuntu系统的一些小技巧总结。</summary></entry><entry><title type="html">泊松方程的有限元求解（理论）</title><link href="http://localhost:4000/math/2018/04/27/poinsonFEM/" rel="alternate" type="text/html" title="泊松方程的有限元求解（理论）" /><published>2018-04-27T00:00:00+08:00</published><updated>2018-04-27T00:00:00+08:00</updated><id>http://localhost:4000/math/2018/04/27/poinsonFEM</id><content type="html" xml:base="http://localhost:4000/math/2018/04/27/poinsonFEM/">&lt;script type=&quot;text/x-mathjax-config&quot;&gt;
  		MathJax.Hub.Config({
            tex2jax: {
                inlineMath: [['$','$'], ['\\(','\\)']]
            },
  			TeX: { 
                equationNumbers: {  
                    autoNumber: &quot;AMS&quot;  
                },
     		    extensions: [&quot;AMSmath.js&quot;]
            },
            CommonHTML: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            &quot;HTML-CSS&quot;: { 
                linebreaks: { 
                    automatic: true 
                } 
            },
            SVG: { 
                linebreaks: { 
                    automatic: true 
                } 
            }
  		});
&lt;/script&gt;

 &lt;script type=&quot;text/javascript&quot; src=&quot;https://cdn.bootcss.com/mathjax/2.7.3/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;
**从泊松方程入手，谈论有限元的一些基本知识。**

---
**本文公式较多，在浏览器中将会花较长时间用于渲染公式。**  
  
--- 
## 泊松方程
泊松方程为
\begin{equation}
\Delta u = f
\end{equation}
在这里$ \Delta $代表的是拉普拉斯算子，而 $ f$和$\varphi $可以是在流形上的实数或复数值的方程。当流形属于欧几里得空间，而拉普拉斯算子通常表示为 ${\nabla}^2$，因此泊松方程通常写成
\begin{equation}
\left( \frac{\partial^2}{\partial x^2} + \frac{\partial^2}{\partial y^2} + \frac{\partial^2}{\partial z^2} \right)\varphi(x,y,z) = f(x,y,z)
\end{equation}

## 具体的问题及求解
我们提出如下的带有边界条件的问题  
$$
\begin{align*} -\Delta u &amp;= f \qquad\qquad &amp; \text{in}\ \Omega, \\ u &amp;= 0 \qquad\qquad &amp; \text{on}\ \partial\Omega. \end{align*}
$$  
求解的区域为平面单位正方形，$\Omega=[0,1]^2$。我们假设一个测试函数$\varphi$，并在上式的左边乘上这个函数，对整个区域$\Omega$积分，可以得到
\begin{equation}
-\int_\Omega \varphi \Delta u = \int_\Omega \varphi f
\end{equation}
由[高斯散度定理（奥斯特罗格拉斯基公式）](https://en.wikipedia.org/wiki/Divergence_theorem)可以得到：
\begin{equation}
\int_\Omega \nabla\varphi \cdot \nabla u - \int_{\partial\Omega} \varphi \mathbf{n}\cdot \nabla u = \int_\Omega \varphi f
\end{equation}
我们需要让$\varphi$也同样满足边界条件（用数学属于描述就是需要让测试函数$\varphi$来自方程解的切空间），因此上式可以写成
\begin{equation}
(\nabla\varphi, \nabla u) = (\varphi, f)
\end{equation}
这里我们使用通用的内积符号$(a,b)=\int_\Omega a\; b$.我们现在的思路就是找到一个解的近似$u_h(\mathbf x)=\sum_j U_j \varphi_j(\mathbf x)$，而$U_j$是我们需要求的系数，$\varphi_i$是我们用的形函数。因此可以得到
\begin{equation}
(\nabla\varphi_i, \nabla u_h) = (\varphi_i, f), \qquad\qquad i=0\ldots N-1.
\end{equation}
现在需要求解一个矩阵代数方程
\begin{equation}
\mathbf{AU}=\mathbf{F}
\end{equation}
矩阵$\mathbf{A},\mathbf{F}$定义为  
$$
\begin{align*} A_{ij} &amp;= (\nabla\varphi_i, \nabla \varphi_j), \\ F_i &amp;= (\varphi_i, f). \end{align*}
$$  
显然，这样就有$\sum_j \mathbf{A}_{ij}\mathbf{U}_j=\mathbf{F}_i$。前面看到我们是左乘$\varphi$，对于对称矩阵（自伴随的），问题是以一样的，不过对于非对称的$\mathbf{A}$，那么经验表明这样会在计算中产生更大的误差。现在整理一下：
* $\mathbf{A,U,F}$都是稀疏矩阵
* 积分的计算采用高斯积分算法  

这样就是全部思路。</content><author><name>scienceasdf</name></author><category term="有限元" /><category term="数值算法" /><summary type="html"></summary></entry></feed>